<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Tomcat单机多实例</title>
      <link href="/2018/06/19/Tomcat%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%AE%9E%E4%BE%8B/"/>
      <url>/2018/06/19/Tomcat%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p><a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat官网</a><br><a href="https://tomcat.apache.org/tomcat-7.0-doc/RUNNING.txt" target="_blank" rel="noopener">官网多实例配置说明</a><br>1、 官网下载 Tomcat 解压版。</p><pre><code class="sh">#下载wget http://apache.fayea.com/tomcat/tomcat-9/v9.0.0.M20/bin/apache-tomcat-9.0.0.M20.tar.gz#解压tar -zxvf apache-tomcat-9.0.0.M20.tar.gz</code></pre><blockquote><p>目录结构：<br>bin (运行脚本）<br>conf (配置文件）<br>lib (核心库文件）<br>logs (日志目录)<br>temp (JVM用于临时文件的目录（java.io.tmpdir)<br>webapps (自动加载的Web应用程序）<br>work (Web应用程序临时工作目录)</p></blockquote><p>以上目录中，只有bin，lib可以被多个实例公用，其它的目录conf、logs、temp、webapps和work文件夹，每个实例必须拥有自己的独立的文件夹</p><p>2、 复制出多个实例</p><pre><code class="sh">#重命名文件夹mv apache-tomcat-9.0.0.M20/ tomcat8080#建立新实例的文件夹mkdir tomcat9090#复制配置文件和应用目录到新的实例目录(如果有自己的特殊目录，一并复制)cp -a tomcat8080/conf/ tomcat9090/cp -a tomcat8080/webapps/ tomcat9090/#新建别的文件夹mkdir logs temp work#新实例conf中修改service.xml中的所有端口（Server port，Connector port ,AJP port）vim tomcat9090/conf/service.xml##自行修改为想要的端口#新实例下建立启动和关闭脚本(内容在下面的代码块)touch start.shtouch stop.sh#修改运行权限chmod +x start.shchmod +x stop.sh</code></pre><p>start.sh 内容</p><pre><code class="sh">export CATALINA_BASE=xxxxxx/tomcat9090（新的实例的目录）export CATALINA_HOME=xxxxxx/tomcat8080（原有实例的目录）cd $CATALINA_HOME/binsh startup.sh</code></pre><p>stop.sh 内容</p><pre><code class="sh">export CATALINA_BASE=xxxxxx/tomcat9090（新的实例的目录）export CATALINA_HOME=xxxxxx/tomcat8080（原有实例的目录）cd $CATALINA_HOME/binsh shutdown.sh</code></pre><p>完成以上步骤，新的tomcat实例可以通过其目录下的start.sh和stop.sh进行启动和关闭了。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker修改默认存储位置</title>
      <link href="/2018/06/19/Docker%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"/>
      <url>/2018/06/19/Docker%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>Docker一般会将数据默认存储到 /var/lib/docker 目录下。<br>使用 docker info 命令可以查看Root Dir 地址：</p><pre><code class="sh">root@xxxxx:~# docker infoContainers: 14 Running: 11 Paused: 0 Stopped: 3Images: 4Server Version: 17.03.1-ceStorage Driver: aufs Root Dir: /var/lib/docker/aufs Backing Filesystem: extfs Dirs: 63 Dirperm1 Supported: trueLogging Driver: json-fileCgroup Driver: cgroupfsPlugins:  Volume: local Network: bridge host macvlan null overlaySwarm: inactiveRuntimes: runcDefault Runtime: runcInit Binary: docker-initcontainerd version: 4ab9917febca54791c5f071a9d1f404867857fccrunc version: 54296cf40ad8143b62dbcaa1d90e520a2136ddfeinit version: 949e6faSecurity Options: apparmor seccomp  Profile: defaultKernel Version: 4.4.0-63-genericOperating System: Ubuntu 16.04.2 LTSOSType: linuxArchitecture: x86_64CPUs: 4Total Memory: 31.42 GiBName: xxxxxxID: NRAQ:FZR6:K24A:JLGZ:WQOD:XHMD:2BPT:S26I:5KMV:7QX2:EHEK:C3CLDocker Root Dir: /var/lib/dockerDebug Mode (client): falseDebug Mode (server): falseRegistry: https://index.docker.io/v1/WARNING: No swap limit supportExperimental: falseInsecure Registries: 127.0.0.0/8Live Restore Enabled: false</code></pre><p>由上面的信息得知Docker的存储位置位于 /var/lib/docker 。那么如果修改其存储位置，只需要讲该目录挂在到一块新的分区或者建立一个软链接到该目录即可。<br>软连接方式：</p><pre><code class="sh">#停止docker服务root@xxxxxx:/var/lib# service docker stop #备份原目录root@xxxxxx:/var/lib# cp -a docker{,_bak}#拷贝数据到新位置root@xxxxxx:/var/lib# cp -a docker/ {new_location}/#建立软连接：root@xxxxxx:/var/lib# rm -rf docker/root@xxxxxx:/var/lib# ln -s {new_location}/ docker#启动dockerroot@xxxxxx:/var/lib# service docker start#检查移动后数据是否完整root@xxxxxx:/var/lib# docker imagesroot@xxxxxx:/var/lib# docker ps -a#如果docker完整并可用，删除备份root@xxxxxx:/var/lib# rm -rf docker_bak/</code></pre><p>挂载新分区的方式，请自行创建新的分区并挂载到/var/lib/docker/目录下（记得分区要设置开机挂载哦）。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker安装与国内加速</title>
      <link href="/2018/06/19/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F/"/>
      <url>/2018/06/19/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F/</url>
      <content type="html"><![CDATA[<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网</a><br><a href="https://github.com/docker/docker" target="_blank" rel="noopener">Docker Github</a><br><a href="https://www.gitbook.com/book/yeasy/docker_practice" target="_blank" rel="noopener">Docker —— 从入门到实践</a><br>Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。（摘自<a href="https://zh.wikipedia.org/wiki/Docker_(%E8%BB%9F%E9%AB%94" target="_blank" rel="noopener">维基百科</a>)）<br>通俗的讲，Docker 就是轻量级的虚拟机。</p><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a><a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-using-the-repository" target="_blank" rel="noopener">Docker 安装</a></h1><p>此处以Ubuntu16（16.10、16.04、14.04均可）为例安装Docker CE，其他系统请参照Docker官网。<a href="http://www.jianshu.com/p/bda22f6db7a8" target="_blank" rel="noopener">查看Ubuntu版本请点击</a></p><ol><li><p>设置更新源</p><pre><code class="sh">#安装基础工具sudo apt-get -y install \apt-transport-https \ca-certificates \curl#信任keycurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -#添加源sudo add-apt-repository \    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \    $(lsb_release -cs) \    stable&quot;#更新源列表sudo apt-get update</code></pre></li><li><p>获取Docker CE</p><pre><code class="sh">sudo apt-get -y install docker-ce</code></pre></li><li><p>测试是否安装成功</p><pre><code class="sh">sudo docker run hello-world</code></pre></li></ol><h1 id="Docker-国内加速"><a href="#Docker-国内加速" class="headerlink" title="Docker 国内加速"></a>Docker 国内加速</h1><p>Docker在国内安装会比较慢，经常会安装失败，如果在安装过程中出现下载某个安装文件失败，可以复制那个安装文件的下载地址，通过VPN之类的机器下载成功后，复制到安装机器进行安装，安装后通过apt -f install 命令安装其他依赖的文件，以可以安装成功。<br>国内有很多Docker的加速器，此处不做对比或测评，本文以阿里云加速器为例使用，阿里云对每个用户有专属加速器地址。<br>首先，你得有阿里云账号，<a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云Docker控制台</a>，在控制台的加速器菜单相项会有各个系统及版本的安装/升级/加速的方法，此处不再复制，请自行前往查看。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于vlmcsd搭建KMS服务器</title>
      <link href="/2018/06/19/%E5%9F%BA%E4%BA%8Evlmcsd%E6%90%AD%E5%BB%BAKMS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/06/19/%E5%9F%BA%E4%BA%8Evlmcsd%E6%90%AD%E5%BB%BAKMS%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1342270-11c187f09bd3c0ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="windows"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基于<a href="https://github.com/Wind4/vlmcsd" target="_blank" rel="noopener">vlmcsd</a>搭建的KMS服务器。<br>KMS Emulator in C (currently runs on Linux including Android, FreeBSD, Solaris, Minix, Mac OS, iOS, Windows with or without Cygwin)<br>vlmcsd论坛源文地址：<a href="https://forums.mydigitallife.net/threads/emulated-kms-servers-on-non-windows-platforms.50234/" target="_blank" rel="noopener">https://forums.mydigitallife.net/threads/emulated-kms-servers-on-non-windows-platforms.50234/</a><br>github：<a href="https://github.com/Wind4/vlmcsd" target="_blank" rel="noopener">https://github.com/Wind4/vlmcsd</a><br>官方激活方法：<a href="http://wind4.github.io/vlmcsd/" target="_blank" rel="noopener">http://wind4.github.io/vlmcsd/</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>Linux服务器（vps也可以）</li><li>vlmcsd 或者 vlmcsdmulti <a href="https://pan.baidu.com/s/1d8mnX0qHvR4Q0bEXB_ciMQ" target="_blank" rel="noopener">百度</a>/<a href="https://mega.nz/#!Z55AyJBC!UMhXr2bcUs3LUOA1R2m3reb-7RiTGoG0oncLx7rKDQw" target="_blank" rel="noopener">MEGA</a>/<a href="https://github.com/Wind4/vlmcsd/releases" target="_blank" rel="noopener">githab</a>(前两个zip的解压密码为2017)</li><li>Windows/Office<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2></li><li><p>根据实际环境选择文件，一般为intel<br><img src="http://upload-images.jianshu.io/upload_images/1342270-a494602a0f24d2ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Linux files"></p></li><li><p>根据CPU架构选择运行文件，vlmcsd或者vlmcsdmulti文件均可<br><img src="http://upload-images.jianshu.io/upload_images/1342270-7d069f673a15982e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vlmcsd"></p></li><li><p>复制上面选择的文件到Linux中，并修改权限为可执行。</p><pre><code class="sh">#本地scp ./vlmcsd-x64-musl-static xxx@host.ip:/opt/kms/#远端chmod u+x /opt/kms/vlmcsd-x64-musl-static</code></pre></li><li>运行vlmcsd并开启端口<pre><code class="sh">./vlmcsd-x64-musl-static#如果没有报错，就运行成功了，如果报错，检查端口占用#centos开启端口对外访问firewall-cmd --zone=public --add-port=1688/tcp --permanentfirewall-cmd reload#本地端口连通性测试telnet you.host.ip port#如果能够联通，就可以进行下一步</code></pre></li><li>激活Windows<br>方法1.slmgr命令激活(管理员权限运行CMD或PowerShell)<pre><code class="sh">#输入以下命令或者将以下命令保存进note并重命名为.bat文件，管理员运行slmgr /skms you.host.ipslmgr /atoslmgr /xpr</code></pre>检查是否激活：<pre><code class="sh">slmgr.vbs -dlv</code></pre>方法2.vlmcs协助<br><img src="http://upload-images.jianshu.io/upload_images/1342270-9e57a0690ed8bfd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vlmcs"><br><img src="http://upload-images.jianshu.io/upload_images/1342270-dbcd1954f29e3bf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vlmcs"><br>选择32还是64请根据实际情况来。<pre><code class="sh">./vlmcs-Windows-x64.exe -v -l 3 you.host.ip#-v输出详细信息#-l 3表示发送Windows 10 Enterprise 2016 LTSB的激活请求，具体版本对应列表可以通过./vlmcs-Windows-x64.exe -x查看</code></pre><img src="http://upload-images.jianshu.io/upload_images/1342270-3fcdbaf65b22b0b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统信息"><br>如果，你不知道你的系统是什么版本，那么。。。<pre><code class="sh">&gt; wmic os get captionCaptionMicrosoft Windows 10 企业版 2016 长期服务版</code></pre></li><li>激活Office<br>OFFICE必须是VOL版本<br><code>`</code>sh<br>#进入office安装目录<br>cd “C:\Program Files\Microsoft Office\Office16”<br>#替换VOL的密钥<br>cscript ospp.vbs /inpkey:XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99<br>#注册kms服务器地址<br>cscript ospp.vbs /sethst:you-kms-server<br>#执行激活<br>cscript ospp.vbs /act<br>#查看状态<br>CSCRIPT OSPP.VBS /DSTATUS</li></ul><p>pause<br><code>`</code><br><strong>如果，windows或者office的密钥有修改过，请重新安装密钥，vol密钥查询地址：<a href="https://technet.microsoft.com/en-us/library/jj612867.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/library/jj612867.aspx</a></strong></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="vlmcsd虚拟机："><a href="#vlmcsd虚拟机：" class="headerlink" title="vlmcsd虚拟机："></a>vlmcsd虚拟机：</h3><p><img src="http://upload-images.jianshu.io/upload_images/1342270-51696bdf2f4e1d2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="floppy144.vfd"><br>新建Linux虚拟机，硬件仅保留内存（最小14MB，推荐16MB）、处理器（1个1核心）、软盘（指向floppy144.flp）、网络适配器（桥接模式）</p><h3 id="slmgr相关命令："><a href="#slmgr相关命令：" class="headerlink" title="slmgr相关命令："></a>slmgr相关命令：</h3><p><img src="http://upload-images.jianshu.io/upload_images/1342270-08967172c184d261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slmgr"><br><img src="http://upload-images.jianshu.io/upload_images/1342270-9ff5e4bdcf220dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slmgr"><br><img src="http://upload-images.jianshu.io/upload_images/1342270-5c9c05421095ea20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slmgr"><br><img src="http://upload-images.jianshu.io/upload_images/1342270-a0d09a5bd20a112c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slmgr"><br><img src="http://upload-images.jianshu.io/upload_images/1342270-37a221bfd20b2c3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slmgr"></p>]]></content>
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7-清除旧内核</title>
      <link href="/2018/06/19/CentOS7-%E6%B8%85%E9%99%A4%E6%97%A7%E5%86%85%E6%A0%B8/"/>
      <url>/2018/06/19/CentOS7-%E6%B8%85%E9%99%A4%E6%97%A7%E5%86%85%E6%A0%B8/</url>
      <content type="html"><![CDATA[<ol><li>列出系统中正在使用的内核:<pre><code class="sh">uname -a   Linux localhost.localdomain 3.10.0-693.21.1.el7.x86_64 #1 SMP Wed Mar 7 19:03:37 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</code></pre></li></ol><p>2.查询系统中全部的内核:</p><pre><code class="sh">rpm -qa | grep kernelkernel-3.10.0-514.el7.x86_64kernel-3.10.0-693.21.1.el7.x86_64abrt-addon-kerneloops-2.1.11-48.el7.centos.x86_64kernel-tools-libs-3.10.0-693.21.1.el7.x86_64kernel-devel-3.10.0-693.21.1.el7.x86_64kernel-tools-3.10.0-693.21.1.el7.x86_64kernel-headers-3.10.0-693.21.1.el7.x86_64kernel-devel-3.10.0-514.el7.x86_64</code></pre><p>3.删除旧的内核</p><pre><code class="sh">yum remove kernel-3.10.0-693.21.1.el7.x86_64</code></pre><p>4.重启后就可以看到多余的启动项也自动被删掉了</p><p>其他：<br>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p><pre><code class="sh">-a或--all：显示全部的信息；-m或--machine：显示电脑类型；-n或-nodename：显示在网络上的主机名称；-r或--release：显示操作系统的发行编号；-s或--sysname：显示操作系统名称；-v：显示操作系统的版本；-p或--processor：输出处理器类型或&quot;unknown&quot;；-i或--hardware-platform：输出硬件平台或&quot;unknown&quot;；-o或--operating-system：输出操作系统名称；--help：显示帮助；--version：显示版本信息。</code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux创建swap分区</title>
      <link href="/2018/06/19/Linux%E5%88%9B%E5%BB%BAswap%E5%88%86%E5%8C%BA/"/>
      <url>/2018/06/19/Linux%E5%88%9B%E5%BB%BAswap%E5%88%86%E5%8C%BA/</url>
      <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/6870cba7gy1fphymz9on9j20h808w75j.jpg" alt="Linux"><br><a href="https://wiki.archlinux.org/index.php/Swap_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Swap分区</a>)，即交换区，Swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。 其实，Swap的调整对Linux服务器，特别是Web服务器的性能至关重要。通过调整Swap，有时可以越过系统性能瓶颈，节省系统升级费用。<br>创建SWAP文件:</p><pre><code class="sh">$ mkdir /swap$ dd if=/dev/zero of=/swap/swap bs=1M count=20482048+0 records in2048+0 records out2147483648 bytes (2.1 GB) copied, 4.47091 s, 480 MB/s</code></pre><p>创建swap分区:</p><pre><code class="sh">$ mkswap /swap/swap Setting up swapspace version 1, size = 2097148 KiBno label, UUID=5a59ae80-a2a5-4899-a080-1e94bdbd8663</code></pre><p>激活swap分区:</p><pre><code class="sh">$ swapon /swap/swap swapon: /swap/swap: insecure permissions 0644, 0600 suggested.</code></pre><p>查看是否生效:</p><pre><code class="sh">$ free -m              total        used        free      shared  buff/cache   availableMem:            992         451          63          84         478         282Swap:          2047           0        2047</code></pre><p>设置重启生效:</p><pre><code class="sh">echo &quot;/swap/swap    swap    swap  defaults    0 0&quot;  &gt;&gt; /etc/fstab </code></pre><hr><p>删除swap分区<br>停止swap分区</p><pre><code class="sh">swapoff   /swap/swap </code></pre><p>删除swap分区文件</p><pre><code class="sh">rm -rf /swap/swap </code></pre><p>删除”/etc/swap”指定文件</p><pre><code class="sh">sed  -i &quot;/&#39;\/swa\/swap   swap   swap  defaults 0 0&#39;//&quot;  /etc/fstab </code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPS安全配置</title>
      <link href="/2018/06/19/VPS%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/06/19/VPS%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1342270-ccd0761a53b44860..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Linux"><br>Linux上通过lastb可以查看到登录失败的日志</p><pre><code class="sh">[root@xxxx ~]# lastbroot     ssh:notty    60.173.82.156    Mon Mar 12 06:11 - 06:11  (00:00)    root     ssh:notty    60.173.82.156    Mon Mar 12 06:11 - 06:11  (00:00)    root     ssh:notty    60.173.82.156    Mon Mar 12 06:11 - 06:11  (00:00)    root     ssh:notty    60.173.82.156    Mon Mar 12 06:11 - 06:11  (00:00)    root     ssh:notty    60.173.82.156    Mon Mar 12 06:11 - 06:11  (00:00)    root     ssh:notty    60.173.82.156    Mon Mar 12 06:10 - 06:10  (00:00)    zhangjun ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    zhangjun ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    centos   ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    centos   ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    hadoop   ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    hadoop   ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    centos   ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    centos   ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:50 - 04:50  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    cgc-admi ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    cgc-admi ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    slide    ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    slide    ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    nagios   ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    nagios   ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:49 - 04:49  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    sshusr   ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    sshusr   ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)    root     ssh:notty    124.68.10.20     Mon Mar 12 04:48 - 04:48  (00:00)</code></pre><p>通过上方显示的结果,有很多机器人在尝试进行登录密码破解.<br>通过查看/var/log/secure文件,里面基本都是一下数据记录:</p><pre><code class="sh">Failed password for root from 124.68.10.20 port 41866 ssh2Received disconnect from 124.68.10.20 port 41866:11: Bye Bye [preauth]Disconnected from 124.68.10.20 port 41866 [preauth]password check failed for user (root)</code></pre><p>统计有多少ip进行过访问:</p><pre><code class="sh">grep &quot;Failed password for invalid&quot; /var/log/secure | awk &#39;{print $13}&#39; | sort | uniq -c | sort -nr | more   1359 114.32.120.181     65 35.200.66.214     36 139.219.109.16     21 124.68.10.20     20 185.165.29.183     18 159.203.36.151     16 41.77.222.57     16 125.234.109.148     15 173.249.29.134     14 58.210.42.4     12 51.15.94.6     10 180.100.217.214      6 218.154.96.152      6 211.229.133.133      6 14.116.254.48      6 104.192.1.30      5 5.101.40.10      4 220.191.194.22      3 111.7.177.239      2 5.101.0.51      2 42.200.170.177      2 213.219.154.68      2 188.6.164.245      2 173.249.15.111      1 77.49.135.119      1 58.56.161.30      1 46.246.39.197      1 42.82.183.121      1 41.236.241.147      1 222.187.225.194      1 178.151.27.227      1 175.33.195.179      1 159.226.169.49      1 14.231.241.207      1 116.231.36.138      1 113.163.198.137</code></pre><p>统计有多少用户名尝试登录(root用户名统计方式不一样，此处未做统计):</p><pre><code class="sh">grep &quot;Failed password for invalid&quot; /var/log/secure | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more    141 admin     42 test     40 oracle     37 user     29 postgres     29 joe     27 webuser     27 webadmin     27 web     27 userftp     27 user2     27 tsserver     27 ts3server     27 ts3     27 ts     27 testuser     27 teste     27 teamspeak3     27 teamspeak     27 system     27 sys     27 student     27 search     27 scott     27 rustserver     27 reporter     27 packer     27 mcserver     27 matrix     27 jenkins     27 itadmin     27 gpadmin     27 exploit     27 elasticsearch     27 elastic     27 csgoserver     26 wp-user     26 wp-admin     26 wp     26 user3     26 user1     26 tomcat     26 sshvpn     26 sinusbot     26 python     26 bot     26 bash     26 apache     25 sentry     24 test1     14 mod      9 centos      9 butter      7 pi      6 SP35      6 guest      5 vbox      5 ubnt      4 transfer      4 testing      4 support      4 grid      4 ec2-user      3 zabbix      3 ubuntu      3 temp      3 telnet</code></pre><p>安全防范:</p><ul><li>修改ssh端口,禁止root登录,使用ssh_key登录,禁止空密码等设置如下<br>编辑/etc/ssh/sshd_config文件,修改以下配置<br><code>`</code>sh<br>Port 6666 #随意修改一个端口<br>PermitRootLogin no #禁止root登录<br>RSAAuthentication yes #RSA认证<br>PubkeyAuthentication yes #开启公钥验证<br>AuthorizedKeysFile .ssh/authorized_keys #验证文件路径<br>PasswordAuthentication no #禁止密码认证<br>PermitEmptyPasswords no #禁止空密码<br>UsePAM no #禁用PAM</li></ul><p>/etc/init.d/ssh restart # 重启ssh服务</p><pre><code>* 使用[denyhosts](http://denyhosts.sourceforge.net)DenyHosts是针对SSH服务器的一个基于日志的入侵预防安全工具，是用Python编写的。其通过监测身份验证登录日志中失败的登录尝试，屏蔽这些登录者的IP地址，从而预防对SSH服务器的暴力破解。通过各个系统的包管理器就可以安装:```sh$ yum install denyhosts</code></pre><p>denyhosts的相关配置项(/etc/denyhosts.conf),如下:</p><pre><code class="sh">SECURE_LOG = /var/log/secure #ssh 日志文件,系统不同,文件不相同HOSTS_DENY = /etc/hosts.deny #控制用户登陆的文件PURGE_DENY = #过多久后清除已经禁止的，空表示永远不解禁BLOCK_SERVICE = sshd #禁止的服务名，如还要添加其他服务，只需添加逗号跟上相应的服务即可DENY_THRESHOLD_INVALID = 5 #允许无效用户失败的次数DENY_THRESHOLD_VALID = 10 #允许普通用户登陆失败的次数DENY_THRESHOLD_ROOT = 1 #允许root登陆失败的次数DENY_THRESHOLD_RESTRICTED = 1WORK_DIR = /var/lib/denyhosts #运行目录SUSPICIOUS_LOGIN_REPORT_ALLOWED_HOSTS=YESHOSTNAME_LOOKUP=YES #是否进行域名反解析LOCK_FILE = /var/run/denyhosts.pid #程序的进程IDADMIN_EMAIL = root@localhost #管理员邮件地址,它会给管理员发邮件SMTP_HOST = localhostSMTP_PORT = 25SMTP_FROM = DenyHosts &lt;nobody@localhost&gt;SMTP_SUBJECT = DenyHosts ReportAGE_RESET_VALID=5d #用户的登录失败计数会在多久以后重置为0，(h表示小时，d表示天，m表示月，w表示周，y表示年)AGE_RESET_ROOT=25dAGE_RESET_RESTRICTED=25dAGE_RESET_INVALID=10dRESET_ON_SUCCESS = yes #如果一个ip登陆成功后，失败的登陆计数是否重置为0DAEMON_LOG = /var/log/denyhosts #自己的日志文件DAEMON_SLEEP = 30s #当以后台方式运行时，每读一次日志文件的时间间隔。</code></pre><p>启动命令（yum安装，已默认配好）</p><pre><code class="sh">service denyhosts startservice denyhosts stopservice denyhosts status</code></pre><p>加入自启动</p><pre><code class="sh">chkconfig denyhosts on</code></pre><p>黑名单白名单位置：</p><pre><code class="sh">vim /etc/hosts.denyvim /etc/hosts.allow</code></pre><p>hosts.allow(hosts.deny同规则)，手工添加：</p><pre><code class="sh">sshd:*.*.*.*</code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux查看资源消耗</title>
      <link href="/2018/06/19/Linux%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97/"/>
      <url>/2018/06/19/Linux%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97/</url>
      <content type="html"><![CDATA[<p>1.CPU占用最多的前10个进程： </p><pre><code class="sh">ps auxw|head -1;ps auxw|sort -rn -k3|head -10 </code></pre><p>2.内存消耗最多的前10个进程 </p><pre><code class="sh">ps auxw|head -1;ps auxw|sort -rn -k4|head -10 </code></pre><p>3.虚拟内存使用最多的前10个进程 </p><pre><code class="sh">ps auxw|head -1;ps auxw|sort -rn -k5|head -10</code></pre><p>4.也可以试试</p><pre><code class="sh">ps auxw --sort=rssps auxw --sort=%cpu</code></pre><p>5.看看几个参数含义</p><p>%MEM 进程的内存占用率<br>MAJFL is the major page fault count,<br>VSZ 进程所使用的虚存的大小<br>RSS 进程使用的驻留集大小或者是实际内存的大小(RSS is the “resident set size” meaning physical memory used)<br>TTY 与进程关联的终端（tty）</p><pre><code>串行端口终端（/dev/ttySn）伪终端（/dev/pty/） 控制终端（/dev/tty） 控制台终端（/dev/ttyn,   /dev/console） 虚拟终端(/dev/pts/n) </code></pre><p>STAT 检查的状态：进程状态使用字符表示的，如R（running正在运行或准备运行）、S（sleeping睡眠）、I（idle空闲）、Z (僵死)、D（不可中断的睡眠，通常是I/O）、P（等待交换页）、W（换出,表示当前页面不在内存）、N（低优先级任务）T(terminate终止)、W has no resident pages</p><pre><code>D    不可中断     Uninterruptible sleep (usually IO) R    正在运行，或在队列中的进程 S    处于休眠状态 T    停止或被追踪 Z    僵尸进程 W    进入内存交换（从内核2.6开始无效） X    死掉的进程 &lt;    高优先级 N    低优先级 L    有些页被锁进内存 s    包含子进程 +    位于后台的进程组； l    多线程，克隆线程  multi-threaded (using CLONE_THREAD, like NPTL pthreads do) </code></pre><hr><p>其他：</p><p>head命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。</p><pre><code class="sh">-n&lt;数字&gt;：指定显示头部内容的行数；-c&lt;字符数&gt;：指定显示头部内容的字符数；-v：总是显示文件名的头信息；-q：不显示文件名的头信息。</code></pre><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。</p><pre><code class="sh">-b：忽略每行前面开始出的空格字符；-c：检查文件是否已经按照顺序排序；-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；-f：排序时，将小写字母视为大写字母；-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；-m：将几个排序号的文件进行合并；-M：将前面3个字母依照月份的缩写进行排序；-n：依照数值的大小排序；-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；-r：以相反的顺序来排序；-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。-k：按照指定需要爱排序的栏位# -n是按照数字大小排序，-r是以相反顺序，-k是指定需要爱排序的栏位，-t指定栏位分隔符为冒号</code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SDKMAN!使用指南</title>
      <link href="/2018/06/19/SDKMAN-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2018/06/19/SDKMAN-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1342270-5b398068c228503e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sdkman.png"></p><h2 id="0-SDKMAN"><a href="#0-SDKMAN" class="headerlink" title="0.SDKMAN!"></a>0.<a href="http://sdkman.io/install.html" target="_blank" rel="noopener">SDKMAN!</a></h2><p>是在大多数基于Unix的系统上管理多个软件开发工具包的并行版本的工具。它提供了一个方便的命令行界面（CLI）和API来安装，切换，删除和列出sdk相关信息。以下是一些特性:</p><ul><li>By Developers, for Developers<br>安装SDK不再需要去各种下载页面去下载,解压,以及设置xxx_HOME或者PATH环境变量.</li><li>多平台<br>可以在任何基于UNIX的平台上运行：Mac OSX，Linux，Cygwin，Solaris和FreeBSD。 <a href="https://github.com/flofreud/posh-gvm" target="_blank" rel="noopener">Powershell CLI</a>版本适用于Windows用户。</li><li>全套JAVA支持<br>为Java，Groovy，Scala，Kotlin和Ceylon等JVM安装软件开发工具包。 Ant，Gradle，Grails，Maven，SBT，Spark，Spring Boot，Vert.x以及其他许多支持。</li><li>APIs<br>使用开放的Broker REST API可以轻松地编写新的客户端。供应商可以通过安全的供应商API发布自己的版本。</li><li>轻量<br>只需要有<a href="http://curl.haxx.se/" target="_blank" rel="noopener">curl</a> \ <a href="http://www.info-zip.org/" target="_blank" rel="noopener">zip/unzip</a>就可以在<a href="https://www.gnu.org/software/bash/" target="_blank" rel="noopener">bash</a>中通过命令使用.还可和<a href="http://www.zsh.org/" target="_blank" rel="noopener">ZSH</a>一起使用.</li></ul><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>在终端中输入以下命令进行安装:</p><pre><code class="sh">$ curl -s &quot;https://get.sdkman.io&quot; | bash</code></pre><p>如果提示缺少zip或unzip,安装后再次执行上面的命令即可.</p><pre><code class="sh"># 安装需要的组件,Ubuntu为例$ apt install zip$ apt install unzip</code></pre><p>安装完成后,在终端中输入:</p><pre><code class="sh">$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</code></pre><p>输入以下命令查看安装情况:</p><pre><code class="sh">$ sdk version# 以下为输出==== BROADCAST =================================================================* 09/01/18: Gradle 4.5-rc-1 released on SDKMAN! #gradle* 06/01/18: sbt 1.1.0 released on SDKMAN! #scala* 20/12/17: Gradle 4.4.1 released on SDKMAN! #gradle================================================================================SDKMAN 5.6.0+287</code></pre><h2 id="2-安装到自定义位置"><a href="#2-安装到自定义位置" class="headerlink" title="2.安装到自定义位置"></a>2.安装到自定义位置</h2><p>SDKMAN的默认安装位置为:$HOME/.sdkman.你可以通过设置SDKMAN_DIR环境变量来修改安装位置:</p><pre><code class="sh">$ export SDKMAN_DIR=&quot;/usr/local/sdkman&quot; &amp;&amp; curl -s &quot;https://get.sdkman.io&quot; | bash</code></pre><h2 id="3-Beta通道"><a href="#3-Beta通道" class="headerlink" title="3.Beta通道"></a>3.Beta通道</h2><p>SDKMAN的Bate版,包含一些cli的新功能,但是可能会不稳定.如果需要使用Bate版本,需要修改~/.sdkman/etc/config文件:</p><pre><code class="sh">sdkman_beta_channel=true</code></pre><p>然后打开一个终端执行:</p><pre><code>$ sdk selfupdate force```sh如果不需要使用Bate版本了,将上面的配置修改为false,再执行一次更新即可.## 4.卸载SDKMAN!没有提供自动化的卸载方法,可以通过以下命令进行卸载:```shtar zcvf ~/sdkman-backup_$(date +%F-%kh%M).tar.gz -C ~/ .sdkman$ rm -rf ~/.sdkman</code></pre><p>然后从.bashrc，.bash_profile和/或.profile文件中编辑和删除初始化代码片段。如果您使用ZSH，请将其从.zshrc文件中删除。要删除的代码片段如下所示：</p><pre><code class="sh">#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!![[ -s &quot;/home/dudette/.sdkman/bin/sdkman-init.sh&quot; ]] &amp;&amp; source &quot;/home/dudette/.sdkman/bin/sdkman-init.sh&quot;</code></pre><h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h2><h3 id="5-0-列出支持的软件"><a href="#5-0-列出支持的软件" class="headerlink" title="5.0 列出支持的软件"></a>5.0 列出支持的软件</h3><pre><code class="sh">$ sdk list# 执行命令后进入vi模式进行阅读,q退出阅读</code></pre><h3 id="5-1-列出软件的版本"><a href="#5-1-列出软件的版本" class="headerlink" title="5.1 列出软件的版本"></a>5.1 列出软件的版本</h3><pre><code class="sh">$ sdk list gradle================================================================================Available Gradle Versions================================================================================     4.5-rc-1             4.2.1                3.1                  2.11            &gt; * 4.4.1                4.2-rc-2             3.0                  2.10                4.4-rc-6             4.2-rc-1             2.9                  2.1                 4.4-rc-5             4.2                  2.8                  2.0                 4.4-rc-4             4.1                  2.7                  1.9                 4.4-rc-3             4.0.2                2.6                  1.8                 4.4-rc-2             4.0.1                2.5                  1.7                 4.4-rc-1             4.0                  2.4                  1.6                 4.4                  3.5.1                2.3                  1.5                 4.3.1                3.5                  2.2.1                1.4                 4.3-rc-4             3.4.1                2.2                  1.3                 4.3-rc-3             3.4                  2.14.1               1.2                 4.3-rc-2             3.3                  2.14                 1.12                4.3-rc-1             3.2.1                2.13                 1.11                4.3                  3.2                  2.12                 1.10           ================================================================================+ - local version* - installed&gt; - currently in use================================================================================```sh### 5.2 安装gradle</code></pre><p>$ sdk install gradle</p><p>Downloading: gradle 4.4.1</p><p>In progress…</p><p>######################################################################## 100.0%</p><p>Installing: gradle 4.4.1<br>Done installing!</p><p>Setting gradle 4.4.1 as default.</p><pre><code>### 5.3 安装指定版本软件```sh# 后面跟上版本号即可$ sdk install gradle 4.4.1</code></pre><h3 id="5-4-安装本地包"><a href="#5-4-安装本地包" class="headerlink" title="5.4 安装本地包"></a>5.4 安装本地包</h3><pre><code class="sh">$ sdk install groovy 3.0.0-SNAPSHOT /path/to/groovy-3.0.0-SNAPSHOT</code></pre><h3 id="5-5-卸载包"><a href="#5-5-卸载包" class="headerlink" title="5.5 卸载包"></a>5.5 卸载包</h3><pre><code class="sh">$ sdk uninstall scala 2.11.6</code></pre><h3 id="5-6-选择版本"><a href="#5-6-选择版本" class="headerlink" title="5.6 选择版本"></a>5.6 选择版本</h3><p>选择一个版本用于当前终端:</p><pre><code class="sh">$ sdk use scala 2.12.1</code></pre><h3 id="5-7-设置默认版本"><a href="#5-7-设置默认版本" class="headerlink" title="5.7 设置默认版本"></a>5.7 设置默认版本</h3><pre><code class="sh">$ sdk default scala 2.11.6</code></pre><h3 id="5-8-查看当前使用的版本"><a href="#5-8-查看当前使用的版本" class="headerlink" title="5.8 查看当前使用的版本"></a>5.8 查看当前使用的版本</h3><pre><code class="sh">$ sdk current java  Using java version 8u111#查看所有本地包的当前版本$ sdk current  Using:  groovy: 2.4.7  java: 8u111  scala: 2.12.1</code></pre><h3 id="5-9-sdk版本升级"><a href="#5-9-sdk版本升级" class="headerlink" title="5.9 sdk版本升级"></a>5.9 sdk版本升级</h3><pre><code class="sh">$ sdk upgrade springboot  Upgrade:  springboot (1.2.4.RELEASE, 1.2.3.RELEASE &lt; 1.2.5.RELEASE)# 本地所有sdk全部升级$ sdk upgrade  Upgrade:  gradle (2.3, 1.11, 2.4, 2.5 &lt; 2.6)  grails (2.5.1 &lt; 3.0.4)  springboot (1.2.4.RELEASE, 1.2.3.RELEASE &lt; 1.2.5.RELEASE)</code></pre><h3 id="5-10-离线模式"><a href="#5-10-离线模式" class="headerlink" title="5.10 离线模式"></a>5.10 离线模式</h3><pre><code class="sh">$ sdk offline enable  Forced offline mode enabled.$ sdk offline disable  Online mode re-enabled!</code></pre><p>当电脑没有网的时候,离线模式会进行自动切换.</p><h3 id="5-11-SDKMAN-版本升级"><a href="#5-11-SDKMAN-版本升级" class="headerlink" title="5.11 SDKMAN!版本升级"></a>5.11 SDKMAN!版本升级</h3><pre><code class="sh">$ sdk selfupdate# 强制重新安装$ sdk selfupdate force</code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nohup命令介绍与应用</title>
      <link href="/2018/06/19/nohup%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2018/06/19/nohup%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><blockquote><p>nohup命令可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。使用nohup命令提交作业，如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件。</p></blockquote><pre><code class="sh">./command &gt; command.outfile 2&gt;&amp;1 &amp;</code></pre><p>将命令command在后台运行，将最终输出保存到文件command.outfile中，命令完成后，直接查看文件即可。&amp;作用是将该条命令加入到一个作业队列中。关闭终端中，该任务终止</p><pre><code class="sh">nohup ./comm &gt; comm.outfile 2&gt;&amp;1 &amp;</code></pre><p>使用nohup可以在关闭终端后继续执行。2&gt;&amp;1是将标准出错定向到标准输出，即标准出错也输出到outfile文件中，如需退出用户，需要使用exit</p><hr><blockquote><p>上面命令里的1和2以及&amp;符号解释:1为程序标准输出,2为程序错误信息输出,2&gt;&amp;1表示将程序的错误信息输出重定向到标准输出,而标准输出即前面的&gt; comm.outfile文件.末尾的&amp;符号表示程序在后台运行.<br>注意:1和2的输出不能为同时指定为同一文件.以下写法错误:<br><code>`</code>sh</p></blockquote><h1 id="错误写法"><a href="#错误写法" class="headerlink" title="错误写法"></a>错误写法</h1><p>nohup ./command.sh &gt;output 2&gt;output</p><pre><code>---```shctrl+z</code></pre><p>可以将正在前台执行的命令放到后台中，并且处于暂停状态</p><pre><code class="sh">ctrl+c</code></pre><p>终止前台命令</p><pre><code class="sh">jobs</code></pre><p>查看当前有多少在后台运行的命令<br>jobs -l 可以显示所有人物的PID</p><pre><code class="sh">bg %n</code></pre><p>将编号为n的任务转后台运行</p><pre><code class="sh">fg %n</code></pre><p>将编号为n的任务转前台运行</p><h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p>当我们需要运行的命令需要sudo权限时,例如如下操作:</p><pre><code class="sh">nohup sudo myscript.sh &amp;</code></pre><p>此时终端只会回复</p><pre><code class="sh">[1] 1220</code></pre><p>没有地方可以进行密码确认.此时有以下两种解决方案:</p><ol><li>删除＆符号，输入密码，然后用Ctrl + Z暂停任务，然后运行bg，以使作业在后台继续运行;</li><li>取巧的解决方法：运行你的任务之前做一个虚拟的sudo（如sudo ls），然后启动您的nohup命令，它不会再次要求您的密码.</li></ol>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> nohup </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git修改远程仓库地址</title>
      <link href="/2018/06/19/git%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/"/>
      <url>/2018/06/19/git%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/</url>
      <content type="html"><![CDATA[<p>GIT中修改远端URL的方法有三种：<br>1.修改命令</p><pre><code class="sh">git remote set-url origin [url]</code></pre><p>2.先删后加</p><pre><code class="sh">git remote rm origingit remote add origin [url]</code></pre><p>3.直接修改config文件，工程目录下的.git文件夹下面的config文件</p><pre><code class="sh">[remote &quot;origin&quot;]    url = git@10.0.63.12:yourProject.git    fetch = +refs/heads/*:refs/remotes/origin/*</code></pre>]]></content>
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS清除用户登录记录和命令历史方法</title>
      <link href="/2018/06/19/CentOS%E6%B8%85%E9%99%A4%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%AE%B0%E5%BD%95%E5%92%8C%E5%91%BD%E4%BB%A4%E5%8E%86%E5%8F%B2%E6%96%B9%E6%B3%95/"/>
      <url>/2018/06/19/CentOS%E6%B8%85%E9%99%A4%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%AE%B0%E5%BD%95%E5%92%8C%E5%91%BD%E4%BB%A4%E5%8E%86%E5%8F%B2%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="登录相关"><a href="#登录相关" class="headerlink" title="登录相关"></a>登录相关</h2><p>Linux系统有三个标准的显示用户最近登录信息的命令： last, lastb,和lastlog。<br>这些命令的输出信息包括登录用户名、最近登录时间、IP地址等。<br>为了更好的保持匿名，你可以清除这些信息。</p><pre><code class="sh">last命令，对应的日志文件/var/log/wtmp； 成功登录用户lastb命令，对应的日志文件/var/log/btmp； 尝试登录信息lastlog命令，对应的日志文件/var/log/lastlog； 显示最近登录信息</code></pre><h3 id="清除登陆系统成功的记录"><a href="#清除登陆系统成功的记录" class="headerlink" title="清除登陆系统成功的记录"></a>清除登陆系统成功的记录</h3><pre><code class="sh">[root@localhost root]#echo &gt; /var/log/wtmp//此文件默认打开时乱码，可查到ip等信息[root@localhost root]#last//此时即查不到用户登录信息</code></pre><h3 id="清除登陆系统失败的记录"><a href="#清除登陆系统失败的记录" class="headerlink" title="清除登陆系统失败的记录"></a>清除登陆系统失败的记录</h3><pre><code class="sh">[root@localhost root]# echo &gt; /var/log/btmp//此文件默认打开时乱码，可查到登陆失败信息[root@localhost root]#lastb//查不到登陆失败信息</code></pre><h2 id="Bash历史相关"><a href="#Bash历史相关" class="headerlink" title="Bash历史相关"></a>Bash历史相关</h2><pre><code class="sh">&lt;空格&gt;command //在执行命令时，指定Bash不保存执行历史history -r //清除当前登录session的历史history -cw //清除所有历史</code></pre><h3 id="清除历史执行命令"><a href="#清除历史执行命令" class="headerlink" title="清除历史执行命令"></a>清除历史执行命令</h3><pre><code class="sh">[root@localhost root]# history -c //清空历史执行命令[root@localhost root]# echo &gt; ./.bash_history//或清空用户目录下的这个文件即可</code></pre><h3 id="导入空历史记录"><a href="#导入空历史记录" class="headerlink" title="导入空历史记录"></a>导入空历史记录</h3><pre><code class="sh">[root@localhost root]# vi /root/history//新建记录文件[root@localhost root]# history -c//清除记录 [root@localhost root]# history -r /root/history.txt//导入记录 [root@localhost root]# history//查询导入结果</code></pre><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><pre><code class="sh">[root@localhost root]# vi /root/history[root@localhost root]# history -c [root@localhost root]# history -r /root/history.txt [root@localhost root]# history [root@localhost root]#echo &gt; /var/log/wtmp  [root@localhost root]#last[root@localhost root]#echo &gt; /var/log/btmp[root@localhost root]#lastb [root@localhost root]#history -c [root@localhost root]#echo &gt; ./.bash_history[root@localhost root]#history</code></pre><p>clear.sh</p><pre><code class="sh">echo &gt; /var/log/wtmpecho &gt; /var/log/btmphistory -cecho &gt; ./.bash_history</code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git服务</title>
      <link href="/2018/06/19/Git%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/06/19/Git%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p><strong>以下命令如果权限不够，请使用sudo</strong></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><pre><code class="sh">#centosyun install git</code></pre><p>或者</p><pre><code class="sh">#ubuntuapt install git</code></pre><p>##添加git用户</p><pre><code class="sh">useradd gitpasswd git #下面为输出Retype new password: passwd: all authentication tokens updated successfully.#如果密码不符合系统规范，会提示相关错误，但是不影响，重新设置就行了。</code></pre><p>命令参考：<br><a href="http://man.linuxde.net/useradd" target="_blank" rel="noopener">useradd</a><br><a href="http://man.linuxde.net/passwd" target="_blank" rel="noopener">passwd</a></p><p>##切换用户</p><pre><code class="sh">su gitcd ~/mkdir gitRepocd gitRepo/mkdir testGitReop.gitcd testGitReop.git/git --bare init</code></pre><p>命令参考：<br><a href="http://man.linuxde.net/su" target="_blank" rel="noopener">su</a></p><p>##使用<br>至此，git仓库已经建立好了。其实，新建用户的名字不一定要git，其他也可以。或者直接使用root用户也可以。但是，在提交工程时，需要输入git服务器对应用户的密码，所以使用root不安全。</p><ul><li>没有新工程，直接同步</li></ul><pre><code class="sh">git clone git@git-server-address:/home/git/gitRepo/testGitReop.git#此处，需要使用到git目录的绝对路径，使用git用户的相对路径会报错：&#39;/git/gitRepo/testGitReop.git&#39; does not appear to be a git repository</code></pre><ul><li>有工程，需要添加到远程仓库并推送<pre><code class="sh">cd myproj-dirgit remote add origin git@git-server-address:/home/git/gitRepo/testGitReop.gitgit add .git commit -m 初始化工程git push -u origin master</code></pre></li></ul><p>##其他<br>如果本地工程的remote地址错了，需要修改：</p><ul><li>修改命令：<pre><code class="sh">git remote set-url origin [url]</code></pre></li><li>先删除，再添加<pre><code class="sh">git remote rm origingit remote add origin [url]</code></pre></li><li>直接修改cnfig文件:<pre><code class="sh">cd .git/vim ./config#修改[remote &quot;origin&quot;] 的 url 的值</code></pre></li><li>使用ssh key：<br>后面补充。。。</li></ul>]]></content>
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu环境变量</title>
      <link href="/2018/06/19/ubuntu%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2018/06/19/ubuntu%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<ol><li><p>临时设置</p><pre><code class="sh">export PATH=/opt/android-studio/bin:$PATH</code></pre></li><li><p>当前用户的全局设置</p><pre><code class="sh">vim ~/.profile</code></pre><p>添加行： </p><pre><code class="sh">export PATH=/opt/android-studio/bin:$PATH </code></pre><p>使生效</p><pre><code class="sh">source ~/.profile</code></pre></li><li><p>所有用户的全局设置</p><pre><code class="sh">vim /etc/profile </code></pre><p>在里面加入： </p><pre><code class="sh">export PATH=/opt/android-studio/bin:$PATH </code></pre><p>使生效 </p><pre><code class="sh">source /etc/profile</code></pre></li></ol>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>查看Ubuntu内核版本和发行版本</title>
      <link href="/2018/06/19/%E6%9F%A5%E7%9C%8BUbuntu%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E5%92%8C%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC/"/>
      <url>/2018/06/19/%E6%9F%A5%E7%9C%8BUbuntu%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E5%92%8C%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC/</url>
      <content type="html"><![CDATA[<h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><p>终端运行命令：</p><pre><code class="sh">xxx@xxx:~$ uname -r4.4.0-63-generic</code></pre><h2 id="内核信息"><a href="#内核信息" class="headerlink" title="内核信息"></a>内核信息</h2><p>终端运行：</p><pre><code class="sh">xxx@xxx:~$ uname -aLinux xxxxx(主机名) 4.4.0-63-generic #84-Ubuntu SMP Wed Feb 1 17:20:32 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h2 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h2><p>终端运行：</p><pre><code class="sh">xxx@xxx:~$ sudo lsb_release -aLSB Version:    core-9.20160110ubuntu0.2-amd64:core-9.20160110ubuntu0.2-noarch:security-9.20160110ubuntu0.2-amd64:security-9.20160110ubuntu0.2-noarchDistributor ID:    UbuntuDescription:    Ubuntu 16.04.2 LTSRelease:    16.04Codename:    xenial</code></pre><p>或者运行：</p><pre><code class="sh">xxx@xxx:~$ cat /etc/issueUbuntu 16.04.2 LTS \n \l</code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu查看cpu信息</title>
      <link href="/2018/06/19/ubuntu%E6%9F%A5%E7%9C%8Bcpu%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/06/19/ubuntu%E6%9F%A5%E7%9C%8Bcpu%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>总核数 = 物理CPU个数 X 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</p><p>查看物理CPU个数</p><pre><code class="sh">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</code></pre><p>查看每个物理CPU中core的个数(即核数)</p><pre><code class="sh">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</code></pre><p>查看逻辑CPU的个数</p><pre><code class="sh">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</code></pre><p>查看CPU信息（型号）</p><pre><code class="sh">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</code></pre><p> 查看内 存信息</p><pre><code class="sh">cat /proc/meminfo</code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot-Scheduled</title>
      <link href="/2018/06/19/SpringBoot-Scheduled/"/>
      <url>/2018/06/19/SpringBoot-Scheduled/</url>
      <content type="html"><![CDATA[<p>在Spring Boot中编写定时任务是非常简单的事,直接使用Scheduled注解就可以完成复杂的定时任务设置.下面是一个10分钟执行定时任务的示例:</p><pre><code class="java">@Scheduled(cron = &quot;0 0/10 * * * ?&quot;)private void schedulerEmptyMsg() {    LogUtils.info(&quot;定时任务执行:&quot; + System.currentTimeMillis());}</code></pre><p>上面的示例中使用了cron表达式,springboot的定时任务还支持其他方式进行定时周期设置:</p><pre><code class="java">@Scheduled(fixedDelay = 5000)//fixedDelay = 5000表示当前方法执行完毕5000ms后，Spring scheduling会再次调用该方法 public void testFixDelay() { } @Scheduled(fixedRate = 5000)//fixedRate = 5000表示当前方法开始执行5000ms后，Spring scheduling会再次调用该方法 public void testFixedRate() { } @Scheduled(initialDelay = 1000, fixedRate = 5000)//initialDelay = 1000表示延迟1000ms执行第一次任务 public void testInitialDelay() { } </code></pre><p>Scheduled注解支持多种参数:</p><ul><li>zone:时区，默认为当前时区.</li><li>fixedDelay:表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms;</li><li>fixedDelayString:与fixedDelay含义一样，只是参数类型变为String;</li><li>fixedRate:表示按一定的频率执行任务，参数类型为long，单位ms;</li><li>fixedRateString:与fixedRate的含义一样，只是将参数类型变为String;</li><li>initialDelay:表示延迟多久再第一次执行任务，参数类型为long，单位ms;</li><li>initialDelayString:与initialDelay的含义一样，只是将参数类型变为String;</li><li>cron:cron表达式.</li></ul><p>Cron表达式:<br><a href="http://qqe2.com/cron/index" target="_blank" rel="noopener">Cron表达式生成器</a><br>Cron表达式是一个字符串，是由空格隔开的6或7个域组成，每一个域对应一个含义(秒 分 时 每月第几天 月 星期 年)其中年是可选字段。</p><p>从左到右分别代表：　秒 分 时 日 月 星期 年份</p><table><thead><tr><th>字段</th><th>允许值</th><th>允许的字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /(0-59的整数)</td></tr><tr><td>分</td><td>0-59</td><td>, - * /(0-59的整数)</td></tr><tr><td>小时</td><td>0-23</td><td>, - * /(0-23的整数)</td></tr><tr><td>日期</td><td>1-31</td><td>, - * ? / L W C(0-31的整数)</td></tr><tr><td>月份</td><td>1-12 or JAN-DEC</td><td>, - * /(1-12的整数或JAN-DEc)</td></tr><tr><td>星期</td><td>1-7 or SUN-SAT</td><td>, - * ? / L C #(1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一)</td></tr><tr><td>年</td><td>1970-2099</td><td>, - * /</td></tr></tbody></table><p>“ <em> ” 表示所有值 在秒的位置写“ </em> ”表示每秒<br>“ ? ” 用来指定“非明确的值”<br>“-” 表示至，例如日期中“2-5”，指的是2号、3号、4号、5号<br>“，” 表示和，例如日期中“2,5”，指的是2号和5号<br>“/” 表示增量，例如上面实现代码中的“0/10”，指的是每隔10秒<br>“,”  表示列出枚举值。例如：在分域使用5,20，则意味着在5和20分时触发一次。<br>“L” 表示最后，只能出现在星期和每月第几天域，如果在星期域使用1L,意味着在最后的一个星期日触发。<br>“W” 表示有效工作日(周一到周五),只能出现在每月第几日域，系统将在离指定日期的最近的有效工作日触发事件。注意一点，W的最近寻找不会跨过月份<br>“LW” 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。<br>“#” 用于确定每个月第几个星期几，只能出现在每月第几天域。例如在1#3，表示某月的第三个星期日。</p><pre><code class="sh">&quot;0 0 * * * *&quot; = 每天的每小时开始时&quot;*/10 * * * * *&quot; = 每10分钟&quot;0 0 8-10 * * *&quot; = 每天的8, 9 和 10 点&quot;0 0 6,19 * * *&quot; = 每天的早上6点和下午7点&quot;0 0/30 8-10 * * *&quot; = 每天的8:00, 8:30, 9:00, 9:30, 10:00 和 10:30,即8-10点,每半小时一次&quot;0 0 9-17 * * MON-FRI&quot; = 每周一至周五，9点到17点的0分0秒执行&quot;0 0 0 25 12 ?&quot; = 每年圣诞节(12月25日)0时0分0秒执行</code></pre>]]></content>
      
      <categories>
          
          <category> JavaWEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/2018/06/19/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2018/06/19/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP状态码</a><br><strong>HTTP状态码</strong>（英语：HTTP Status Code）是用以表示<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">网页服务器</a><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输协议</a>响应状态的3位数字代码。它由 <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC 2616</a> 规范定义的，并得到 <a href="https://tools.ietf.org/html/rfc2518" target="_blank" rel="noopener">RFC 2518</a>、<a href="https://tools.ietf.org/html/rfc2817" target="_blank" rel="noopener">RFC 2817</a>、<a href="https://tools.ietf.org/html/rfc2295" target="_blank" rel="noopener">RFC 2295</a>、<a href="https://tools.ietf.org/html/rfc2774" target="_blank" rel="noopener">RFC 2774</a> 与 <a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a> 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP / 1.1标准（<a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener">RFC 7231</a>）的一部分。</p><p><img src="http://upload-images.jianshu.io/upload_images/1342270-300c0ac92324e1ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="statuscode.jpg"></p><h2 id="1xx消息"><a href="#1xx消息" class="headerlink" title="1xx消息"></a>1xx消息</h2><blockquote><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p></blockquote><table><thead><tr><th>状态码</th><th>对应消息</th><th>备注</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送Expect: 100-continue作为头部，并在发送正文之前接收100 Continue状态代码。响应代码417期望失败表示请求不应继续。</td></tr><tr><td>101</td><td>Switching Protocols</td><td>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。<br>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如<a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">HTTP/2</a>）比旧版本更有优势，或者切换到一个实时且同步的协议（如<a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a>）以传送利用此类特性的资源。</td></tr><tr><td>102</td><td>Processing（<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc2518" target="_blank" rel="noopener">RFC 2518</a>）</td><td>WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。</td></tr></tbody></table><h2 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h2><blockquote><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p></blockquote><table><thead><tr><th>状态码</th><th>对应消息</th><th>备注</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。</td></tr><tr><td>201</td><td>Created</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其<a href="https://zh.wikipedia.org/wiki/URI" target="_blank" rel="noopener">URI</a>已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#202" target="_blank" rel="noopener">202 Accepted</a>‘。</td></tr><tr><td>202</td><td>Accepted</td><td>服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。</td></tr><tr><td>203</td><td>Non-Authoritative Information（自HTTP / 1.1起）</td><td>服务器是一个转换代理服务器（transforming proxy，例如<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%8A%A0%E9%80%9F%E5%99%A8" target="_blank" rel="noopener">网络加速器</a>），以200 OK 状态码为起源，但回应了原始响应的修改版本。</td></tr><tr><td>204</td><td>No Content</td><td>服务器成功处理了请求，没有返回任何内容。</td></tr><tr><td>205</td><td>Reset Content</td><td>服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。</td></tr><tr><td>206</td><td>Partial Content（<a href="https://tools.ietf.org/html/rfc7233" target="_blank" rel="noopener">RFC 7233</a>）</td><td>服务器已经成功处理了部分GET请求。类似于<a href="https://zh.wikipedia.org/wiki/FlashGet" target="_blank" rel="noopener">FlashGet</a>或者<a href="https://zh.wikipedia.org/wiki/%E8%BF%85%E9%9B%B7" target="_blank" rel="noopener">迅雷</a>这类的HTTP <a href="https://zh.wikipedia.org/wiki/Category:%E4%B8%8B%E8%BC%89%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">下载工具</a>都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</td></tr><tr><td>207</td><td>Multi-Status（WebDAV；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a>）</td><td>代表之后的消息体将是一个<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a>消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>208</td><td>Already Reported （WebDAV；<a href="https://tools.ietf.org/html/rfc5842" target="_blank" rel="noopener">RFC 5842</a>）</td><td>DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。</td></tr><tr><td>226</td><td>IM Used （<a href="https://tools.ietf.org/html/rfc3229" target="_blank" rel="noopener">RFC 3229</a>）</td><td>服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。</td></tr></tbody></table><h2 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h2><blockquote><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。<br>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户<a href="https://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">浏览器</a>才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测<a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E5%BE%AA%E7%92%B0" target="_blank" rel="noopener">无限循环</a>重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</p></blockquote><table><thead><tr><th>状态码</th><th>对应消息</th><th>备注</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br>除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。<br>如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的<a href="https://zh.wikipedia.org/wiki/URI" target="_blank" rel="noopener">URI</a>；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/HTTP_301" target="_blank" rel="noopener">301</a></td><td><a href="https://zh.wikipedia.org/wiki/HTTP_301" target="_blank" rel="noopener">Moved Permanently</a></td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br>新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">超链接</a>及简短说明。<br>如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/HTTP_302" target="_blank" rel="noopener">302</a></td><td><a href="https://zh.wikipedia.org/wiki/HTTP_302" target="_blank" rel="noopener">Found</a></td><td>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/HTTP_303" target="_blank" rel="noopener">303</a></td><td><a href="https://zh.wikipedia.org/wiki/HTTP_303" target="_blank" rel="noopener">See Other</a></td><td>对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<br>新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td>304</td><td>Not Modified</td><td>表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</td></tr><tr><td>305</td><td>Use Proxy</td><td>被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。许多HTTP客户端（像是Mozilla和Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。<br>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td>306</td><td>Switch Proxy</td><td>在最新版的规范中，306状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/HTTP_307" target="_blank" rel="noopener">307</a></td><td><a href="https://zh.wikipedia.org/wiki/HTTP_307" target="_blank" rel="noopener">Temporary Redirect</a></td><td>在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。</td></tr><tr><td>308</td><td>Permanent Redirect (<a href="https://tools.ietf.org/html/rfc7538" target="_blank" rel="noopener">RFC 7538</a>)</td><td>请求和所有将来的请求应该使用另一个URI重复。 307和308重复302和301的行为，但不允许HTTP方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。</td></tr></tbody></table><h2 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h2><blockquote><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p></blockquote><table><thead><tr><th>状态码</th><th>对应消息</th><th>备注</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。</td></tr><tr><td>401</td><td>Unauthorized（<a href="https://tools.ietf.org/html/rfc7235" target="_blank" rel="noopener">RFC 7235</a>）</td><td>类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。<br>注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。</td></tr><tr><td>402</td><td>Payment Required</td><td>该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，<a href="https://zh.wikipedia.org/wiki/Google_Developers" title="Google Developers" target="_blank" rel="noopener">Google Developers</a>API会使用此状态码。</td></tr><tr><td>403</td><td><a href="https://zh.wikipedia.org/wiki/HTTP_403" target="_blank" rel="noopener">Forbidden</a></td><td>服务器已经理解请求，但是拒绝执行它。与<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#401" target="_blank" rel="noopener">401响应</a>不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#404" target="_blank" rel="noopener">404响应</a>，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td><a href="https://zh.wikipedia.org/wiki/HTTP_404" target="_blank" rel="noopener">Not Found</a></td><td>请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#410" target="_blank" rel="noopener">410状态码</a>来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>Not Acceptable</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>Proxy Authentication Required（<a href="https://tools.ietf.org/html/rfc2617" target="_blank" rel="noopener">RFC 2617</a>）</td><td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时。根据HTTP规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>Conflict</td><td>表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BC%96%E8%BE%91%E5%86%B2%E7%AA%81&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">编辑冲突</a>。</td></tr><tr><td>410</td><td>Gone</td><td>表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到410状态码后，用户应停止再次请求资源。但大多数服务端不会使用此状态码，而是直接使用<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#404" target="_blank" rel="noopener">404状态码</a>。</td></tr><tr><td>411</td><td>Length Required</td><td>服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>Precondition Failed（<a href="https://tools.ietf.org/html/rfc7232" target="_blank" rel="noopener">RFC 7232</a>）</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>Request Entity Too Large（<a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener">RFC 7231</a>）</td><td>前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>Request-URI Too Long（<a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener">RFC 7231</a>）</td><td>前称“Request-URI Too Long”，表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为GET请求的查询字符串，在这种情况下，应将其转换为POST请求。这比较少见，通常的情况包括：<br>&gt; 本应使用POST方法的表单提交变成了GET方法，导致查询字符串过长。<br>&gt; 重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。<br>&gt; 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>对于当前请求的方法和所请求的资源，请求中提交的<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B" title="互联网媒体类型" target="_blank" rel="noopener">互联网媒体类型</a>并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为svg，但服务器要求图像使用上传格式为jpg。</td></tr><tr><td>416</td><td>Requested Range Not Satisfiable（<a href="https://tools.ietf.org/html/rfc7233" target="_blank" rel="noopener">RFC 7233</a>）</td><td>前称“Requested Range Not Satisfiable”。客户端已经要求文件的一部分（<a href="https://zh.wikipedia.org/w/index.php?title=Byte_serving&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Byte serving</a>），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。</td></tr><tr><td>417</td><td>Expectation Failed</td><td>在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1" title="路由" target="_blank" rel="noopener">路由</a>的下一个节点上，Expect的内容无法被满足。</td></tr><tr><td>418</td><td>I’m a teapot（<a href="https://tools.ietf.org/html/rfc2324" target="_blank" rel="noopener">RFC 2324</a>）</td><td>本操作码是在1998年作为<a href="https://zh.wikipedia.org/wiki/IETF" title="IETF" target="_blank" rel="noopener">IETF</a>的传统<a href="https://zh.wikipedia.org/wiki/%E6%83%A1%E6%90%9ERFC" title="恶搞RFC" target="_blank" rel="noopener">愚人节笑话</a>, 在RFC 2324<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E5%92%96%E5%95%A1%E5%A3%B6%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" title="超文本咖啡壶控制协议" target="_blank" rel="noopener">超文本咖啡壶控制协议</a>‘中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的<a href="https://zh.wikipedia.org/wiki/HTCPCP" title="HTCPCP" target="_blank" rel="noopener">HTCPCP</a>收到BREW或POST指令要求其煮咖啡时应当回传此错误。这个HTTP状态码在某些网站（包括Google.com）与项目（如<a href="https://zh.wikipedia.org/wiki/Node.js" title="Node.js" target="_blank" rel="noopener">Node.js</a>、<a href="https://zh.wikipedia.org/wiki/ASP.NET" title="ASP.NET" target="_blank" rel="noopener">ASP.NET</a>和<a href="https://zh.wikipedia.org/wiki/Go%E8%AF%AD%E8%A8%80" title="Go语言" target="_blank" rel="noopener">Go语言</a>）中用作<a href="https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%9B%8B_(%E5%AA%92%E4%BD%93" target="_blank" rel="noopener">彩蛋</a> “彩蛋 (媒体)”)。</td></tr><tr><td>420</td><td>Enhance Your Caim</td><td>Twitter Search与Trends API在客户端被限速的情况下返回。</td></tr><tr><td>421</td><td>Misdirected Request （<a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">RFC 7540</a>）</td><td>该请求针对的是无法产生响应的服务器（例如因为连接重用）。</td></tr><tr><td>422</td><td>Unprocessable Entity（<a href="https://zh.wikipedia.org/wiki/WebDAV" title="WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a> ）</td><td>请求格式正确，但是由于含有<a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89" title="语义" target="_blank" rel="noopener">语义</a>错误，无法响应。</td></tr><tr><td>423</td><td>Locked（<a href="https://zh.wikipedia.org/wiki/WebDAV" title="WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a>）</td><td>当前资源被锁定.</td></tr><tr><td>424</td><td>Failed Dependency（<a href="https://zh.wikipedia.org/wiki/WebDAV" title="WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a>）</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。</td></tr><tr><td>425</td><td>Unodered Cellection</td><td>在WebDAV Advanced Collections Protocol中定义，但Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol中并不存在。</td></tr><tr><td>426</td><td>Upgrade Required（<a href="https://tools.ietf.org/html/rfc2817" target="_blank" rel="noopener">RFC 2817</a>）</td><td>客户端应当切换到<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8" title="传输层安全" target="_blank" rel="noopener">TLS/1.0</a>，并在<a href="https://zh.wikipedia.org/w/index.php?title=HTTP/1.1_Upgrade_header&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">HTTP/1.1 Upgrade header</a>中给出。</td></tr><tr><td>428</td><td>Precondition Required (<a href="https://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a>)</td><td>原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。</td></tr><tr><td>429</td><td>oo Many Requests （<a href="https://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a>）</td><td>用户在给定的时间内发送了太多的请求。旨在用于<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BD%91%E7%BB%9C%E9%99%90%E9%80%9F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">网络限速</a>。</td></tr><tr><td>431</td><td>Request Header Fields Too Large （<a href="https://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a>）</td><td>服务器不愿处理请求，因为一个或多个头字段过大。</td></tr><tr><td>444</td><td>No Response</td><td>Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。</td></tr><tr><td>450</td><td>Blocked by Windows Parental Controls</td><td>这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。</td></tr><tr><td>452</td><td><a href="https://zh.wikipedia.org/wiki/HTTP_451" target="_blank" rel="noopener">Unavailable For Legal Reasons</a></td><td>该访问因<a href="https://zh.wikipedia.org/wiki/%E6%B3%95%E5%BE%8B" title="法律" target="_blank" rel="noopener">法律</a>的要求而被拒绝，由<a href="https://zh.wikipedia.org/wiki/IETF" title="IETF" target="_blank" rel="noopener">IETF</a>在2015核准后新增加。</td></tr><tr><td>494</td><td>Request Header Too Large</td><td>在错误代码431提出之前Nginx上使用的扩展HTTP代码。</td></tr></tbody></table><h2 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h2><blockquote><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。</p></blockquote><table><thead><tr><th>状态码</th><th>对应消息</th><th>备注</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能）</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3" title="网关" target="_blank" rel="noopener">网关</a>或者<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" title="代理服务器" target="_blank" rel="noopener">代理</a>工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于临时的服务器维护或者<a href="https://zh.wikipedia.org/w/index.php?title=%E8%BF%87%E8%BD%BD&amp;action=edit&amp;redlink=1" title="过载（页面不存在）" target="_blank" rel="noopener">过载</a>，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理<a href="https://zh.wikipedia.org/w/index.php?title=500_Internal_Error&amp;action=edit&amp;redlink=1" title="500 Internal Error（页面不存在）" target="_blank" rel="noopener">500响应</a>的方式处理它。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误。</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>Variant Also Negotiates（<a href="https://tools.ietf.org/html/rfc2295" target="_blank" rel="noopener">RFC 2295</a>）</td><td>由《透明内容协商协议》（<a href="https://tools.ietf.org/html/rfc2295" target="_blank" rel="noopener">RFC 2295</a>）扩展，代表服务器存在内部配置错误，被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>Insufficient Storage（<a href="https://zh.wikipedia.org/wiki/WebDAV" title="WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a>）</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。</td></tr><tr><td>508</td><td>Loop Detected （<a href="https://zh.wikipedia.org/wiki/WebDAV" title="WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc5842" target="_blank" rel="noopener">RFC 5842</a>）</td><td>服务器在处理请求时陷入死循环。 （可代替 <a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#208" target="_blank" rel="noopener">208状态码</a>）</td></tr><tr><td>510</td><td>Not Extended（<a href="https://tools.ietf.org/html/rfc2774" target="_blank" rel="noopener">RFC 2774</a>）</td><td>获取资源所需要的策略并没有被满足。</td></tr><tr><td>511</td><td>Network Authentication Required （<a href="https://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a>）</td><td>客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。（例如连接<a href="https://zh.wikipedia.org/wiki/%E7%83%AD%E7%82%B9_(Wi-Fi" target="_blank" rel="noopener">WiFi热点</a> “热点 (Wi-Fi)”)时的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BC%BA%E5%88%B6%E7%BD%91%E7%BB%9C%E9%97%A8%E6%88%B7&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">强制网络门户</a>）</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL的utf8与utf8mb4</title>
      <link href="/2018/06/19/MySQL%E7%9A%84utf8%E4%B8%8Eutf8mb4/"/>
      <url>/2018/06/19/MySQL%E7%9A%84utf8%E4%B8%8Eutf8mb4/</url>
      <content type="html"><![CDATA[<p>报错信息：</p><pre><code class="java">java.lang.RuntimeException: java.sql.SQLException: Incorrect string value: &#39;\\xF0\\x9F\\x9A\\xB9\\xE4\\xBC...&#39; for column &#39;xxx&#39; ...</code></pre><p>引起的原因：<br>在varchar类型的字段里面插入的text包含emoj表情。<br>MySQL 5.5.3 版本以下，CHARACTER SET 为 utf8 的字段最长只有3个字节。<br>查看MySQL版本可用以下命令：</p><pre><code class="sh">mysql&gt; status;--------------mysql  Ver 14.14 Distrib 5.7.17, for Linux (x86_64) using  EditLine wrapperConnection id:        5Current database:    Current user:        root@localhostSSL:            Not in useCurrent pager:        stdoutUsing outfile:        &#39;&#39;Using delimiter:    ;Server version:        5.7.17-0ubuntu0.16.04.1 (Ubuntu)Protocol version:    10Connection:        Localhost via UNIX socketServer characterset:    utf8mb4Db     characterset:    utf8mb4Client characterset:    utf8mb4Conn.  characterset:    utf8mb4UNIX socket:        /var/run/mysqld/mysqld.sockUptime:            1 hour 28 min 58 secThreads: 1  Questions: 28  Slow queries: 0  Opens: 116  Flush tables: 1  Open tables: 29  Queries per second avg: 0.005--------------</code></pre><p>查看相关字符集设置信息(下面是我修改后的，修改前utf8mb4处都为utf8)：</p><pre><code class="sh">mysql&gt;  show variables like &#39;character_set_%&#39;;+--------------------------+----------------------------+| Variable_name            | Value                      |+--------------------------+----------------------------+| character_set_client     | utf8mb4                    || character_set_connection | utf8mb4                    || character_set_database   | utf8mb4                    || character_set_filesystem | binary                     || character_set_results    | utf8mb4                    || character_set_server     | utf8mb4                    || character_set_system     | utf8                       || character_sets_dir       | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+</code></pre><p>查看所有字符集信息：</p><pre><code class="sh">mysql&gt; show character set;+----------+---------------------------------+---------------------+--------+| Charset  | Description                     | Default collation   | Maxlen |+----------+---------------------------------+---------------------+--------+| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 || dec8     | DEC West European               | dec8_swedish_ci     |      1 || cp850    | DOS West European               | cp850_general_ci    |      1 || hp8      | HP West European                | hp8_english_ci      |      1 || koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 || latin1   | cp1252 West European            | latin1_swedish_ci   |      1 || latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 || swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 || ascii    | US ASCII                        | ascii_general_ci    |      1 || ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 || sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 || hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 || tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 || euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 || koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 || gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 || greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 || cp1250   | Windows Central European        | cp1250_general_ci   |      1 || gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 || latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 || armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 || utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 || ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 || cp866    | DOS Russian                     | cp866_general_ci    |      1 || keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 || macce    | Mac Central European            | macce_general_ci    |      1 || macroman | Mac West European               | macroman_general_ci |      1 || cp852    | DOS Central European            | cp852_general_ci    |      1 || latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 || utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 || cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 || utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 || utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 || cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 || cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 || utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 || binary   | Binary pseudo charset           | binary              |      1 || geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 || cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 || eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 || gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |+----------+---------------------------------+---------------------+--------+</code></pre><p>由上表可见，utf8最长3个字节。</p><p>在5.5.3版本以后，增加了 [utf8mb4] (<a href="https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html</a>) 字符集。<br>这是官方原文：</p><blockquote><p>The character set named utf8 uses a maximum of three bytes per character and contains only BMP characters. As of MySQL 5.5.3, the utf8mb4 character set uses a maximum of four bytes per character supports supplementary characters：</p><ul><li>For a BMP character, utf8 and utf8mb4 have identical storage characteristics: same code values, same encoding, same length.</li><li>For a supplementary character, utf8 cannot store the character at all, whereas utf8mb4 requires four bytes to store it. Because utf8 cannot store the character at all, you have no supplementary characters in utf8 columns and need not worry about converting characters or losing data when upgrading utf8 data from older versions of MySQL.</li></ul></blockquote><p>因此，只需要将字符集由utf8修改为utf8mb4即可支持4字节的BPM等数据。</p><p>如何修改：<br>修改MySQL配置文件，修改mysql的客户端默认连接字符集，服务端以及数据库的默认字符集：</p><pre><code class="sh">sudo vim /etc/mysql/my.cnf</code></pre><p>在末尾或者已有的中括号里的块中加上如下配置：</p><pre><code class="sh">[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ciinit_connect=&#39;SET NAMES utf8mb4&#39;</code></pre><p>重启MySQL服务：</p><pre><code class="sh">sudo service mysql restart</code></pre><p>重启服务后，通过以下SQL可以查看结果：</p><pre><code class="sh">mysql&gt; SHOW VARIABLES WHERE Variable_name LIKE &#39;character\_set\_%&#39; OR Variable_name LIKE &#39;collation%&#39;;+--------------------------+--------------------+| Variable_name            | Value              |+--------------------------+--------------------+| character_set_client     | utf8mb4            || character_set_connection | utf8mb4            || character_set_database   | utf8mb4            || character_set_filesystem | binary             || character_set_results    | utf8mb4            || character_set_server     | utf8mb4            || character_set_system     | utf8               || collation_connection     | utf8mb4_unicode_ci || collation_database       | utf8mb4_unicode_ci || collation_server         | utf8mb4_unicode_ci |+--------------------------+--------------------+</code></pre><p>MySQL方面修改好后，需要修改已有的数据库或者表或者字段：<br>修改表的字符集：</p><pre><code class="sh">ALTER TABLE tablename charset=utf8mb4;</code></pre><p>修改表字段：</p><pre><code class="sh">ALTER TABLE tablename MODIFY COLUMN columnname VARCHAR(255) CHARACTER SET utf8mb4;</code></pre><p>修改表的字符集和修改字段可以用一条SQL完成。</p><p>如果使用的java连接MySQL，需要修改原有的连接设置：<br>原jdbcUrl：jdbc:mysql:///dbname?useUnicode=true&amp;characterEncoding=UTF-8<br>需要去掉编码参数：<br>jdbcUrl：jdbc:mysql:///dbname</p><p>** 此处不要想当然的将参数useUnicode=true&amp;characterEncoding=UTF-8修改为useUnicode=true&amp;characterEncoding=utf8mb4<br>，否则会报出以下错误：</p><pre><code class="sh">Could not get JDBC Connection; nested exception is com.MySQL.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown character set: &#39;utf8mb4&#39;</code></pre><p>我们在MySQL的配置文件里已经配置了[client]的默认访问字符集了，所以，此处将参数去掉即可。</p><p>吃水不忘打井人：<br><a href="http://blog.csdn.net/secretx/article/details/21253559" target="_blank" rel="noopener">http://blog.csdn.net/secretx/article/details/21253559</a><br><a href="http://stackoverflow.com/questions/7814293/how-to-insert-utf-8-mb4-characteremoji-in-ios5-in-mysql" target="_blank" rel="noopener">http://stackoverflow.com/questions/7814293/how-to-insert-utf-8-mb4-characteremoji-in-ios5-in-mysql</a></p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL允许局域网连接</title>
      <link href="/2018/06/19/MySQL%E5%85%81%E8%AE%B8%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/06/19/MySQL%E5%85%81%E8%AE%B8%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ubuntu安装mysql：</p><pre><code class="sh">sudo apt install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-dev</code></pre><p>第一步安装过程中会进行root用户的密码输入（两次）；<br>安装完成后是有以下命令判断是否安装成功：</p><pre><code class="sh">sudo netstat -tap | grep mysql</code></pre><p>出现以下结果表示安装成功：</p><pre><code class="sh">tcp        0      0 *:mysql                 *:*                     LISTEN      16601/mysqld</code></pre><h2 id="修改连接"><a href="#修改连接" class="headerlink" title="修改连接"></a>修改连接</h2><pre><code class="sh">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>注释其中的：bind-address = 127.0.0.1配置或者修改为bind-address = 0.0.0.0，来允许所有IP访问，或者输入一个你指定的IP地址。<br>保存推出后使用以下命令重启mysql：</p><pre><code class="sh">sudo /etc/init.d/mysql restart</code></pre><p>使用以下命令登陆进入mysql后修改访问权限：</p><pre><code class="sh">mysql -u root -p输入密码use mysql//授权用户能进行远程连接grant all privileges on *.* to root@&quot;%&quot; identified by &quot;password&quot; with grant option;//刷新权限信息flush privileges;</code></pre><p>命令中的两个星号，第一个星号表示数据库名称，第二个星号表示该数据库下的某个表名称。写成两个星号表示所有的数据库都进行授权。<br>root表示授权root账号。<br>“%”表示授权的用户IP可以指定，这里代表任意的IP地址都能访问MySQL数据库。<br>“password”表示分配账号对应的密码，这里密码自己替换成你的mysql root帐号密码。<br>所以此处可以写成：</p><pre><code class="sh">grant all PRIVILEGES on testdabatase.testtable to username@&#39;192.168.1.2&#39; identified by &#39;user-pass&#39;;</code></pre><p>最后附：<br><a href="http://pan.baidu.com/s/1sl74roD" target="_blank" rel="noopener">Navicat Premium_11.2.7简体中文32&amp;64&amp;破解</a></p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android指纹识别</title>
      <link href="/2018/06/19/Android%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
      <url>/2018/06/19/Android%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/9fd3b88a6f78" target="_blank" rel="noopener">上一篇</a>讲了通过<a href="https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html" target="_blank" rel="noopener">FingerprintManager</a>验证手机是否支持指纹识别,以及是否录入了指纹,这里进行指纹的验证.</p><pre><code class="java">//获取FingerprintManager实例FingerprintManager mFingerprintManager =                                                (FingerprintManager) context.getSystemService(Context.FINGERPRINT_SERVICE);//执行验证监听mFingerprintManager                .authenticate(cryptoObject, mCancellationSignal, 0, this, null);</code></pre><p>参数说明:</p><pre><code class="java">cryptoObject//FingerprintManager支持的加密对象的包装类。目前该框架支持Signature，Cipher和Mac对象。mCancellationSignal//提供取消正在进行的操作的功能。callback(参数中的this)//指纹识别的回调函数</code></pre><p>cryptoObject初始化:</p><pre><code class="java">private KeyguardManager mKeyguardManager;private FingerprintManager mFingerprintManager;private static final String DIALOG_FRAGMENT_TAG = &quot;myFragment&quot;;private static final String SECRET_MESSAGE = &quot;Very secret message&quot;;public static boolean isAuthenticating = false;public static final String PARAM_DISMISS_DIALOG = &quot;param_dismiss_dialog&quot;;/** * Alias for our key in the Android Key Store */private static final String KEY_NAME = &quot;my_key&quot;;private KeyStore mKeyStore;private KeyGenerator mKeyGenerator;private Cipher mCipher;@TargetApi(Build.VERSION_CODES.M)private boolean initCipher() {    try {        mCipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + &quot;/&quot;                + KeyProperties.BLOCK_MODE_CBC + &quot;/&quot;                + KeyProperties.ENCRYPTION_PADDING_PKCS7);    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {        throw new RuntimeException(&quot;Failed to get an instance of Cipher&quot;, e);    }    try {        mKeyStore.load(null);        SecretKey key = (SecretKey) mKeyStore.getKey(KEY_NAME, null);        mCipher.init(Cipher.ENCRYPT_MODE, key);        return true;    } catch (KeyPermanentlyInvalidatedException e) {        return false;    } catch (KeyStoreException | CertificateException | UnrecoverableKeyException | IOException            | NoSuchAlgorithmException | InvalidKeyException e) {        throw new RuntimeException(&quot;Failed to init Cipher&quot;, e);    }}/** * Creates a symmetric key in the Android Key Store which can only be used after the user has * authenticated with fingerprint. */@TargetApi(Build.VERSION_CODES.M)public void createKey() {    // The enrolling flow for fingerprint. This is where you ask the user to set up fingerprint    // for your flow. Use of keys is necessary if you need to know if the set of    // enrolled fingerprints has changed.    mKeyStore = null;    mKeyGenerator = null;    try {        mKeyStore = KeyStore.getInstance(&quot;AndroidKeyStore&quot;);    } catch (KeyStoreException e) {        throw new RuntimeException(&quot;Failed to get an instance of KeyStore&quot;, e);    }    try {        mKeyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, &quot;AndroidKeyStore&quot;);    } catch (NoSuchAlgorithmException | NoSuchProviderException e) {        throw new RuntimeException(&quot;Failed to get an instance of KeyGenerator&quot;, e);    }    try {        mKeyStore.load(null);        // Set the alias of the entry in Android KeyStore where the key will appear        // and the constrains (purposes) in the constructor of the Builder        mKeyGenerator.init(new KeyGenParameterSpec.Builder(KEY_NAME,                KeyProperties.PURPOSE_ENCRYPT |                        KeyProperties.PURPOSE_DECRYPT)                .setBlockModes(KeyProperties.BLOCK_MODE_CBC)                // Require the user to authenticate with a fingerprint to authorize every use                // of the key                .setUserAuthenticationRequired(true)                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)                .build());        mKeyGenerator.generateKey();    } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException            | CertificateException | IOException e) {        throw new RuntimeException(e);    }}</code></pre><pre><code class="java">FingerprintManager.CryptoObject cryptoObject = new FingerprintManager.CryptoObject(mCipher);</code></pre><p>回调函数:</p><pre><code class="java">@Overridepublic void onAuthenticationError(int errMsgId, CharSequence errString) {    //验证出现错误了    //errString为错误的信息}@Overridepublic void onAuthenticationHelp(int helpMsgId, CharSequence helpString) {    showError(helpString);    //验证出现一些问题的系统提示,比如:请按久一点等提示信息.}@Overridepublic void onAuthenticationFailed() {    showError(&quot;指纹验证失败&quot;);    //在验证失败和出现问题以后,系统会继续执行监听,使用者需要在这里修改相关提示信息}@Overridepublic void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {    //验证成功}</code></pre>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>检查Android是否支持指纹识别以及是否已经录入指纹</title>
      <link href="/2018/06/19/%E6%A3%80%E6%9F%A5Android%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E4%BB%A5%E5%8F%8A%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E5%BD%95%E5%85%A5%E6%8C%87%E7%BA%B9/"/>
      <url>/2018/06/19/%E6%A3%80%E6%9F%A5Android%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E4%BB%A5%E5%8F%8A%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E5%BD%95%E5%85%A5%E6%8C%87%E7%BA%B9/</url>
      <content type="html"><![CDATA[<p>Android M 开始,系统中加入了指纹相关功能.<br>主要用到的类为:<a href="https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html" target="_blank" rel="noopener">FingerprintManager</a><br>只提供三个方法:</p><table><thead><tr><th>返回值</th><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>void</td><td>authenticate(FingerprintManager.CryptoObject crypto, CancellationSignal cancel, int flags, FingerprintManager.AuthenticationCallback callback, Handler handler)</td><td>用于指纹验证</td></tr><tr><td>boolean</td><td><a href="https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html#hasEnrolledFingerprints(" target="_blank" rel="noopener">hasEnrolledFingerprints</a>)()</td><td>确定是否至少有一个指纹登记。</td></tr><tr><td>boolean</td><td><a href="https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html#isHardwareDetected(" target="_blank" rel="noopener">isHardwareDetected</a>)()</td><td>确定指纹硬件是否存在并且功能正常。</td></tr></tbody></table><p>那么有了以上方法,就可以很简单的判断手机是否支持指纹,以及是否有指纹录入.以下为代码实现:</p><pre><code class="java">/**     * 检查指纹     *     * @param context     * @return     */    public static rx.Observable&lt;java.lang.Boolean&gt; checkFingerprint(final Context context) {        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) {            return //请求指纹权限                    new RxPermissions(context)                            .request(Manifest.permission.USE_FINGERPRINT)                            .map(new Func1&lt;Boolean, Boolean&gt;() {                                @TargetApi(Build.VERSION_CODES.M)                                @Override                                public Boolean call(Boolean aBoolean) {                                    if (aBoolean) {                                        FingerprintManager fingerprintManager =                                                (FingerprintManager) context.getSystemService(Context.FINGERPRINT_SERVICE);                                        //确定是否指纹硬件存在和功能                                        return fingerprintManager.isHardwareDetected() &amp;&amp; fingerprintManager.hasEnrolledFingerprints();                                    }                                    return false;                                }                            });        } else {            return rx.Observable.create(new Observable.OnSubscribe&lt;Boolean&gt;() {                @Override                public void call(Subscriber&lt;? super Boolean&gt; subscriber) {                    subscriber.onNext(false);                }            });        }    }</code></pre>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tinker命令行接入操作</title>
      <link href="/2018/06/19/tinker%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/19/tinker%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>这里只讲tinker命令行方式接入的一些操作和问题,tinker请查看:<br>tinker:<a href="https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97</a></p><p>cli:tinker-patch-cli-1.9.2.jar<br>下载:<a href="https://pan.baidu.com/s/1kW2p55P" target="_blank" rel="noopener">https://pan.baidu.com/s/1kW2p55P</a><br>cli使用:</p><pre><code class="sh">java -jar tinker-patch-cli-1.9.2.jar -old ./xxx_signed.apk -new ./xxx_signed.apk -config tinker_config.xml -out out/</code></pre><p>tinker_config.xml文件:</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--command version is not recommended, you must add the tinker proguard file and multiDex keep file yourself--&gt;&lt;!--further, you must put TINKER_ID in your your AndroidManifest.xml such as &lt;meta-data android:name=&quot;TINKER_ID&quot; android:value=&quot;b168b32&quot;/&gt;--&gt;&lt;!--and you&#39;d better use applymapping to build the patch apk--&gt;&lt;tinkerPatch&gt;    &lt;issue id=&quot;property&quot;&gt;        &lt;!--there are some cases we may get some warnings, default false--&gt;        &lt;!--if ignoreWarning is true, we would just assert the patch process--&gt;        &lt;!--case 1: minSdkVersion is below 14, but you are using dexMode with raw.--&gt;        &lt;!--it must be crash when load.--&gt;        &lt;!--case 2: newly added Android Component in AndroidManifest.xml,--&gt;        &lt;!--it must be crash when load.--&gt;        &lt;!--case 3: loader classes in dex.loader{} are not keep in the main dex,--&gt;        &lt;!--it must be let tinker not work.--&gt;        &lt;!--case 4: loader classes in dex.loader{} changes,--&gt;        &lt;!--loader classes is ues to load patch dex. it is useless to change them.--&gt;        &lt;!--it won&#39;t crash, but these changes can&#39;t effect. you may ignore it--&gt;        &lt;ignoreWarning value=&quot;false&quot;/&gt;        &lt;!--whether sign the patch file default true--&gt;        &lt;!--if not, you must do yourself. otherwise it can&#39;t check success during the patch loading--&gt;        &lt;!--we will use the sign config with your build type--&gt;        &lt;useSign value=&quot;true&quot;/&gt;        &lt;!--if you don&#39;t set sevenZip path, we just use 7za to try--&gt;        &lt;sevenZipPath value=&quot;/usr/bin/7za&quot;/&gt;        &lt;!--Whether tinker should treat the base apk as the one being protected by app--&gt;        &lt;!--protection tools.--&gt;        &lt;!--If this attribute is true, the generated patch package will contain a--&gt;        &lt;!--dex including all changed classes instead of any dexdiff patch-info files.--&gt;        &lt;isProtectedApp value=&quot;false&quot;/&gt;        &lt;!--Whether tinker should support component hotplug (add new component dynamically).--&gt;        &lt;!--If this attribute is true, the component added in new apk will be available after--&gt;        &lt;!--patch is successfully loaded. Otherwise an error would be announced when generating patch--&gt;        &lt;!--on compile-time.--&gt;        &lt;!----&gt;        &lt;!--Notice that currently this feature is incubating and only support NON-EXPORTED Activity--&gt;        &lt;supportHotplugComponent value=&quot;false&quot;/&gt;    &lt;/issue&gt;    &lt;issue id=&quot;dex&quot;&gt;        &lt;!--only can be &#39;raw&#39; or &#39;jar&#39;. for raw, we would keep its original format--&gt;        &lt;!--for jar, we would repack dexes with zip format.--&gt;        &lt;!--if you want to support below 14, you must use jar--&gt;        &lt;!--or you want to save rom or check quicker, you can use raw mode also--&gt;        &lt;dexMode value=&quot;jar&quot;/&gt;        &lt;!--what dexes in apk are expected to deal with tinkerPatch--&gt;        &lt;!--it support * or ? pattern.--&gt;        &lt;pattern value=&quot;classes*.dex&quot;/&gt;        &lt;pattern value=&quot;assets/secondary-dex-?.jar&quot;/&gt;        &lt;!--Warning, it is very very important, loader classes can&#39;t change with patch.--&gt;        &lt;!--thus, they will be removed from patch dexes.--&gt;        &lt;!--you must put the following class into main dex.--&gt;        &lt;!--Simply, you should add your own application {@code tinker.sample.android.SampleApplication}--&gt;        &lt;!--own tinkerLoader {@code SampleTinkerLoader}, and the classes you use in them--&gt;        &lt;loader value=&quot;com.tencent.tinker.loader.*&quot;/&gt;        &lt;loader value=&quot;tinker.sample.android.SampleApplication&quot;/&gt;    &lt;/issue&gt;    &lt;issue id=&quot;lib&quot;&gt;        &lt;!--what library in apk are expected to deal with tinkerPatch--&gt;        &lt;!--it support * or ? pattern.--&gt;        &lt;!--for library in assets, we would just recover them in the patch directory--&gt;        &lt;!--you can get them in TinkerLoadResult with Tinker--&gt;        &lt;pattern value=&quot;lib/*/*.so&quot;/&gt;    &lt;/issue&gt;    &lt;issue id=&quot;resource&quot;&gt;        &lt;!--what resource in apk are expected to deal with tinkerPatch--&gt;        &lt;!--it support * or ? pattern.--&gt;        &lt;!--you must include all your resources in apk here--&gt;        &lt;!--otherwise, they won&#39;t repack in the new apk resources--&gt;        &lt;pattern value=&quot;res/*&quot;/&gt;        &lt;pattern value=&quot;assets/*&quot;/&gt;        &lt;pattern value=&quot;resources.arsc&quot;/&gt;        &lt;pattern value=&quot;AndroidManifest.xml&quot;/&gt;        &lt;!--ignore add, delete or modify resource change--&gt;        &lt;!--Warning, we can only use for files no relative with resources.arsc, such as assets files--&gt;        &lt;!--it support * or ? pattern.--&gt;        &lt;!--Such as I want assets/meta.txt use the base.apk version whatever it is change ir not.--&gt;        &lt;ignoreChange value=&quot;assets/sample_meta.txt&quot;/&gt;        &lt;!--default 100kb--&gt;        &lt;!--for modify resource, if it is larger than &#39;largeModSize&#39;--&gt;        &lt;!--we would like to use bsdiff algorithm to reduce patch file size--&gt;        &lt;largeModSize value=&quot;100&quot;/&gt;    &lt;/issue&gt;    &lt;issue id=&quot;packageConfig&quot;&gt;        &lt;!--package meta file gen. path is assets/package_meta.txt in patch file--&gt;        &lt;!--you can use securityCheck.getPackageProperties() in your ownPackageCheck method--&gt;        &lt;!--or TinkerLoadResult.getPackageConfigByName--&gt;        &lt;!--you must add TINKER_ID with the old apk manifest&#39;s meta TINKER_ID value--&gt;        &lt;!--other config files (such as patchMessage below)is not necessary--&gt;        &lt;!--For sample project or any projects that copy SamplePatchListener directory,--&gt;        &lt;!--platform config field is necessary, or an error code ERROR_PATCH_CONDITION_NOT_SATISFIED(-10)--&gt;        &lt;!--will be thrown.--&gt;        &lt;configField name=&quot;platform&quot; value=&quot;all&quot;/&gt;        &lt;configField name=&quot;patchMessage&quot; value=&quot;classes.dex&quot;/&gt;    &lt;/issue&gt;    &lt;!--sign, if you want to sign the apk, and if you want to use 7zip, you must fill in the following data--&gt;    &lt;issue id=&quot;sign&quot;&gt;        &lt;!--the signature file path, in window use \, in linux use /, and the default path is the running location--&gt;        &lt;path value=&quot;keystore/xxx.jks&quot;/&gt;        &lt;!--storepass--&gt;        &lt;storepass value=&quot;xxxx&quot;/&gt;        &lt;!--keypass--&gt;        &lt;keypass value=&quot;xxxx&quot;/&gt;        &lt;!--alias--&gt;        &lt;alias value=&quot;xxxx&quot;/&gt;    &lt;/issue&gt;&lt;/tinkerPatch&gt;</code></pre><p>1.需要修改的地方:文件最末尾的sing块,修改为自己的证书相关信息.<br>2.如果7za没有在系统中安装,需要先安装,否则无法打7zip包.</p><pre><code class="sh">apt install p7zip-full</code></pre><p>安装后查看7za文件位置,再修改配置中sevenZipPath指定的位置.<br>3.如果涉及到代码混淆,multidex等问题,请参考<a href="https://github.com/Tencent/tinker/tree/master/tinker-build/tinker-patch-cli/tool_output" target="_blank" rel="noopener">tinker-build</a>项目中的文件.</p>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> tinker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android闹钟服务AlarmManager</title>
      <link href="/2018/06/19/Android%E9%97%B9%E9%92%9F%E6%9C%8D%E5%8A%A1AlarmManager/"/>
      <url>/2018/06/19/Android%E9%97%B9%E9%92%9F%E6%9C%8D%E5%8A%A1AlarmManager/</url>
      <content type="html"><![CDATA[<h2 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h2><pre><code class="java">AlarmManager mAlarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);</code></pre><h2 id="设置闹钟"><a href="#设置闹钟" class="headerlink" title="设置闹钟"></a>设置闹钟</h2><h3 id="Android4-4以上"><a href="#Android4-4以上" class="headerlink" title="Android4.4以上"></a>Android4.4以上</h3><p>方法声明：</p><pre><code class="java">public void setWindow(int type, long windowStartMillis, long windowLengthMillis, PendingIntent operation)/*int type:闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME：表示闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3；AlarmManager.ELAPSED_REALTIME_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2；AlarmManager.RTC：表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1；AlarmManager.RTC_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0；AlarmManager.POWER_OFF_WAKEUP：表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；long windowStartMillis：闹钟的开始时间long windowLengthMillis：闹钟窗口时长PendingIntent operation：需要执行的操作*/</code></pre><p>示例：</p><pre><code class="java">//设置一个10分钟后执行的闹钟，此方法只设置一次mAlarmManager.setWindow(AlarmManager.RTC_WAKEUP,                    System.currentTimeMillis() + 10 * minuteMills,                    2 * minuteMills,                    yourPendingIntent;</code></pre><p><strong>注意:</strong>如果设置的起始时间小于当前时间，闹钟将会马上被触发。如果触发的事件里面又设置了一次闹钟（相当于递归），就会进入死循环。</p><h3 id="Android4-4以下："><a href="#Android4-4以下：" class="headerlink" title="Android4.4以下："></a>Android4.4以下：</h3><p>方法声明：</p><pre><code class="java">//注册一个新的闹铃，一次性闹钟set(int type, long triggerAtMillis, PendingIntent operation)//注册一个新的闹铃，这个闹铃将在指定的时间被准确的执行setExact(int type, long triggerAtMillis, PendingIntent operation)//注册一个对触发时间并不是很精准的闹铃，也就是闹钟间隔时间不固定，例如，一个闹铃每小时都会重复，但不一定都是在每个小时的最开始被触发//triggerAtMillis为闹钟首次执行时间，intervalMillis为闹钟两次执行的时间间隔setInexactRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)//注册一个重复类型的闹铃setRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)//设定系统时钟时间setTime(long millis)//设置系统默认时区setTimeZone(String timeZone)//得到下一个闹钟，返回值AlarmManager.AlarmClockInfogetNextAlarmClock()//和set方法类似，这个闹钟运行在系统处于低电模式时有效setAndAllowWhileIdle(int type, long triggerAtMillis, PendingIntent operation) </code></pre><p>示例：</p><pre><code class="java">//设置单次闹钟mAlarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + minuteMills, yourPendingIntent);//设置重复闹钟mAlarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP,                    System.currentTimeMillis() + minuteMills,                    10 * minuteMills,                    yourPendingIntent);</code></pre><h2 id="取消闹钟"><a href="#取消闹钟" class="headerlink" title="取消闹钟"></a>取消闹钟</h2><pre><code class="java">//取消参数匹配的闹铃mAlarmManager.cancel(yourPendingIntent);</code></pre><p>闹钟为系统级别的一种通知，可以不依赖于应用的存活为条件，因此也可以用于应用挂掉后定时重启应用等场景。</p><pre><code class="java">//定时重启Intent intent = getPackageManager().getLaunchIntentForPackage(getPackageName());PendingIntent restartIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, 0);AlarmManager mgr = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 500, restartIntent); // 定时重启应用</code></pre>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> AlarmManager </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebView geolocation 相关</title>
      <link href="/2018/06/19/WebView-geolocation%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/06/19/WebView-geolocation%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<ol><li>需要允许WebView使用JS<pre><code class="java">WebSettings.setJavaScriptEnabled(true);</code></pre></li><li>应用需要ACCESS_FINE_LOCATION权限(6.0以上运行时获取)；<pre><code class="java">&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</code></pre>最好声明多个权限，用来确定定位信息：<pre><code class="java">&lt;uses-permission android:name=&quot;android.permission.ACCESS_GPS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_ASSISTED_GPS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</code></pre></li><li>WebView需要设置一个自定义的WebChromeClient，需要实现WebChromeClient.onGeolocationPermissionsShowPrompt()方法用来处理js请求定位权限。如下是一个简单的实现：<pre><code class="java">webView.setWebChromeClient(new WebChromeClient() {public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) { callback.invoke(origin, true, false);}});</code></pre></li><li>WebView的定位数据储存在sqlite数据库中，通过WebSettings.setGeolocationDatabasePath(…)方法可以设置数据库存储位置。如下设置定位信息存储的数据库的放置位置：<pre><code class="java">webView.getSettings().setGeolocationDatabasePath( context.getFilesDir().getPath() );</code></pre></li></ol>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> WebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebViewClient与WebChromeClient</title>
      <link href="/2018/06/19/WebViewClient%E4%B8%8EWebChromeClient/"/>
      <url>/2018/06/19/WebViewClient%E4%B8%8EWebChromeClient/</url>
      <content type="html"><![CDATA[<h2 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a><a href="https://developer.android.com/reference/android/webkit/WebViewClient.html" target="_blank" rel="noopener">WebViewClient</a></h2><p>WebViewClient中的常用方法有:</p><ul><li>onPageFinished(WebView view, String url)</li><li>onPageStarted(WebView view, String url, Bitmap favicon)</li><li>onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)</li><li>shouldInterceptRequest(WebView view, String url)</li><li>shouldOverrideUrlLoading(WebView view, String url)<br>等,以上方法都是webview中请求过程等事件的处理方法.</li></ul><h2 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a><a href="https://developer.android.com/reference/android/webkit/WebChromeClient.html" target="_blank" rel="noopener">WebChromeClient</a></h2><p>WebChromeClient中的常用方法有:</p><ul><li>onCloseWindow(WebView window)</li><li>onConsoleMessage(ConsoleMessage consoleMessage)</li><li>onJsAlert(WebView view, String url, String message, JsResult result)</li><li>onJsConfirm(WebView view, String url, String message, JsResult result)</li><li>onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result)</li><li>onPermissionRequest(PermissionRequest request)</li><li>onReceivedIcon(WebView view, Bitmap icon)</li><li>onReceivedTitle(WebView view, String title)</li><li>onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)<br>等,以上方法都是webview和用户之间有交互的一些方法,如JS弹窗,文件选择弹窗,窗口关闭等</li></ul>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> WebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 应用内存管理-onTrimMemory,onLowMemory</title>
      <link href="/2018/06/19/Android%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-onTrimMemory-onLowMemory/"/>
      <url>/2018/06/19/Android%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-onTrimMemory-onLowMemory/</url>
      <content type="html"><![CDATA[<h2 id="onLowMemory"><a href="#onLowMemory" class="headerlink" title="onLowMemory)"></a><a href="https://developer.android.com/reference/android/content/ComponentCallbacks.html#onLowMemory(" target="_blank" rel="noopener">onLowMemory</a>)</h2><p>onLowMemory是Android提供的API，当整个系统运行内存不足时，就会被调用。<br>系统为其提供回调的组件有:<a href="https://developer.android.com/reference/android/app/Application.html#onLowMemory(" target="_blank" rel="noopener">Application</a>)/<a href="https://developer.android.com/reference/android/app/Activity.html#onLowMemory(" target="_blank" rel="noopener">Activity</a>)/<a href="https://developer.android.com/reference/android/app/Fragment.html#onLowMemory(" target="_blank" rel="noopener">Fragment</a>)/<a href="https://developer.android.com/reference/android/app/Service.html#onLowMemory(" target="_blank" rel="noopener">Service</a>)/<a href="https://developer.android.com/reference/android/content/ContentProvider.html#onLowMemory(" target="_blank" rel="noopener">ContentProvider</a>)<br>系统为其提供回调的接口有:<br><a href="https://developer.android.com/reference/android/content/ComponentCallbacks.html" target="_blank" rel="noopener">ComponentCallbacks</a>/<a href="https://developer.android.com/reference/android/content/ComponentCallbacks2.html" target="_blank" rel="noopener">ComponentCallbacks2</a><br>组件通过覆写onLowMemory方法的形式监听,接口通过以下方式进行注册监听(其实四大组件也是实现了ComponentCallbacks接口):</p><pre><code class="java">public static class MyCallback implements ComponentCallbacks {         @Override        public void onConfigurationChanged(Configuration arg) {         }        @Override        public void onLowMemory() {            //do release operation        }    }Context.registerComponentCallbacks()</code></pre><p>onLowMemory 当后台程序已经终止资源还匮乏时会调用这个方法。好的应用程序一般会在这个方法里面释放一些不必要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况。</p><h2 id="onTrimMemory"><a href="#onTrimMemory" class="headerlink" title="onTrimMemory"></a><a href="https://developer.android.com/reference/android/content/ComponentCallbacks2.html" target="_blank" rel="noopener">onTrimMemory</a></h2><p>OnTrimMemory是Android 4.0之后提供的API，系统会根据不同的内存状态来回调。系统提供的回调有：</p><ul><li>Application.onTrimMemory()</li><li>Activity.onTrimMemory()</li><li>Fragement.OnTrimMemory()</li><li>Service.onTrimMemory()</li><li>ContentProvider.OnTrimMemory()</li></ul><p>OnTrimMemory的参数是一个int数值，代表不同的内存状态：</p><ul><li>TRIM_MEMORY_COMPLETE：内存不足，并且该进程在后台进程列表最后一个，马上就要被清理</li><li>TRIM_MEMORY_MODERATE：内存不足，并且该进程在后台进程列表的中部。</li><li>TRIM_MEMORY_BACKGROUND：内存不足，并且该进程是后台进程。</li><li>TRIM_MEMORY_UI_HIDDEN：内存不足，并且该进程的UI已经不可见了。      </li></ul><p>以上4个是4.0增加</p><ul><li>TRIM_MEMORY_RUNNING_CRITICAL：内存不足(后台进程不足3个)，并且该进程优先级比较高，需要清理内存</li><li>TRIM_MEMORY_RUNNING_LOW：内存不足(后台进程不足5个)，并且该进程优先级比较高，需要清理内存</li><li>TRIM_MEMORY_RUNNING_MODERATE：内存不足(后台进程超过5个)，并且该进程优先级比较高，需要清理内存       </li></ul><p>以上3个是4.1增加</p><p>系统也提供了一个ComponentCallbacks2，通过Context.registerComponentCallbacks()注册后，就会被系统回调到。</p><h2 id="onLowMemory和onTrimMemory的比较"><a href="#onLowMemory和onTrimMemory的比较" class="headerlink" title="onLowMemory和onTrimMemory的比较"></a>onLowMemory和onTrimMemory的比较</h2><p>1，onLowMemory被回调时，已经没有后台进程；而onTrimMemory被回调时，还有后台进程。<br>2，onLowMemory是在最后一个后台进程被杀时调用，一般情况是low memory killer 杀进程后触发；而onTrimMemory的触发更频繁，每次计算进程优先级时，只要满足条件，都会触发。<br>3，通过一键清理后，onLowMemory不会被触发，而onTrimMemory会被触发一次。</p><p><a href="https://developer.android.com/reference/android/content/ComponentCallbacks2.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/ComponentCallbacks2.html</a></p>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>华为桌面未读角标</title>
      <link href="/2018/06/19/%E5%8D%8E%E4%B8%BA%E6%A1%8C%E9%9D%A2%E6%9C%AA%E8%AF%BB%E8%A7%92%E6%A0%87/"/>
      <url>/2018/06/19/%E5%8D%8E%E4%B8%BA%E6%A1%8C%E9%9D%A2%E6%9C%AA%E8%AF%BB%E8%A7%92%E6%A0%87/</url>
      <content type="html"><![CDATA[<p>角标功能支持平台：EMUI4.1及以上，桌面版本：6.3.29</p><ol><li>声明权限，如下：<pre><code>&lt;uses-permission android:name=&quot; com.huawei.android.launcher.permission. CHANGE_BADGE&quot;/&gt;</code></pre></li><li>在需要进行角标显示地方，采用如下方法传递数据给华为桌面应用<pre><code class="java">Bundle extra =new Bundle();extra.putString(&quot;package&quot;,  &quot;xxxxxx&quot;);extra.putString(&quot;class&quot;, &quot;yyyyyyy&quot;);extra.putInt(&quot;badgenumber&quot;, i);context.getContentResolver().call(Uri.parse(&quot;content://com.huawei.android.launcher.settings/badge/&quot;), &quot;change_badge&quot;, null, extra);</code></pre>关键参数说明【红色部分为填充参数】<br>package:应用包名<br>class:桌面图标对应的应用入口Activity类<br>badgenumber:角标数字</li></ol><p>示例：</p><pre><code class="java">/* * 是否支持华为徽章 * */private boolean isHuaweiSupport = true;if (isHuaweiSupport) {  huaweiShortCut(num);}//华为显示角标private void huaweiShortCut(int aCount) {    try {        Bundle extra = new Bundle();        extra.putString(&quot;package&quot;, x.app().getApplicationContext().getPackageName());        extra.putString(&quot;class&quot;, Utils.AppUtils.getLaunchActivityName());        extra.putInt(&quot;badgenumber&quot;, aCount);        x.app().getApplicationContext().getContentResolver().call(Uri.parse(&quot;content://com.huawei.android.launcher.settings/badge/&quot;), &quot;change_badge&quot;, null, extra);    } catch (Exception aE) {        isHuaweiSupport = false;    }}</code></pre><ol start="3"><li>特殊情形考虑：</li></ol><p>对于第三应用打开和退出时，是否还继续显示角标取决应用传递的值（badgenumber为0时，不显示角标；badgenumber大于0时，显示角标）</p><p>当第三方应用package和class发生变化时，需传递该变化后的信息</p>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu-nginx-Supervisor</title>
      <link href="/2018/06/19/ubuntu-nginx-Supervisor/"/>
      <url>/2018/06/19/ubuntu-nginx-Supervisor/</url>
      <content type="html"><![CDATA[<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>安装：sudo apt-get install nginx<br>配置文件：sudo vim /etc/nginx/sites-available/default</p><pre><code class="bash"># nginx -c /etc/nginx/nginx.conf 关闭 nginx# nginx -s stop重读配置文件# nginx -s reload# pkill -HUP nginx重新打开日志文件# nginx -s reopen# pkill -USR1 nginx还可以下载 nginx RPM 包中的 /etc/init.d/nginx 文件，修改路径后即可使用：# service nginx {start|stop|status|restart|reload|configtest|}</code></pre><pre><code class="bash">server {    listen 80 default_server;    listen [::]:80 default_server ipv6only=on;    # 如果要支持HTTPS，修改这里    # 可以使用 https://letsencrypt.org 的免费SSL证书    #listen 443 ssl;    #ssl_certificate     www.example.com.crt;    #ssl_certificate_key www.example.com.key;    #ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;    #ssl_ciphers         HIGH:!aNULL:!MD5;    # 重定向所有HTTP到HTTPS    # rewrite ^(.*)$ https://$host$1 permanent;    # 网站根目录，根据需要修改    root /usr/share/nginx/html;    # 增加index.php    index index.php index.html index.htm;    # 假设域名是 ssl.mcxiaoke.com    server_name ssl.mcxiaoke.com; #绑定域名    location / {        try_files $uri $uri/ =404;    }    error_page 404 /404.html;    error_page 500 502 503 504 /50x.html;    location = /50x.html {        root /usr/share/nginx/html;    }    #支持php-fpm的配置    location ~ \.php$ {        try_files $uri =404;        fastcgi_split_path_info ^(.+\.php)(/.+)$;        fastcgi_pass unix:/var/run/php5-fpm.sock;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    }}</code></pre><p>##Supervisor<br>安装：sudo apt-get install supervisor<br>创建一个supervisor配置文件</p><pre><code class="bash">[program:myapp]command = gunicorn myapp:app -b localhost:8000directory = /home/mcxiaoke/myappuser = mcxiaoke</code></pre><p>读取并执行任务</p><pre><code class="bash">sudo pkill gunicornsudo supervisorctl rereadsudo supervisorctl updatesudo supervisorctl start myapp</code></pre>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python-mongodb</title>
      <link href="/2018/06/19/python-mongodb/"/>
      <url>/2018/06/19/python-mongodb/</url>
      <content type="html"><![CDATA[<pre><code class="shell">install pip:    sudo apt-get install python3-pipupgrading pip:    pip install -U pip(on linux or macos)    python -m pip install -U pip(on windows)install pymongo:    sudo pip install pymongosudo apt-get install mongodbmkdir /data/dbstart mongodb:./bin/mongod --dbpath=/data/dbstart mongodb daemon:    mkdir /log    mongod --dbpath=/data/db/ --fork --logpath=/log/mongodb.log    or    mkdir /opt/mongodb/conf.d/mongodb.conf    vim /opt/mongodb/conf.d/mongodb.conf    and paste bellow:        port=27017        dbpath=/data/db        logpath=/log/mongodb.log        logappend=true        fork=true    mongod -c /opt/mongodb/conf.d/mongodb.conf</code></pre><p>connect.py</p><p><code>`</code>py<br>import pymongo<br>from pymongo import *</p><h1 id="get-database-connection"><a href="#get-database-connection" class="headerlink" title="get database connection"></a>get database connection</h1><p>client = MongoClient()</p><h1 id="the-same-way"><a href="#the-same-way" class="headerlink" title="the same way"></a>the same way</h1><h1 id="client-MongoClient-“localhost”-27017"><a href="#client-MongoClient-“localhost”-27017" class="headerlink" title="client = MongoClient(“localhost”,27017)"></a>client = MongoClient(“localhost”,27017)</h1><h1 id="client-MongoClient-“mongodb-localhost-27017-“"><a href="#client-MongoClient-“mongodb-localhost-27017-“" class="headerlink" title="client = MongoClient(“mongodb://localhost:27017/“)"></a>client = MongoClient(“mongodb://localhost:27017/“)</h1><h1 id="assign-database-and-collection-to-operat"><a href="#assign-database-and-collection-to-operat" class="headerlink" title="assign database and collection to operat"></a>assign database and collection to operat</h1><p>db = client.test_db<br>collection = db.test_collection</p><h1 id="IDUS"><a href="#IDUS" class="headerlink" title="IDUS"></a>IDUS</h1><h1 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h1><p>mydict = {“name”: “cursor”, “sex”: “female”, “job”: “dev”}<br>collection.insert(mydict)<br>collection.insert_one(mydict)<br>mylist = []<br>mylist.append(mydict)</p><h1 id="insert-many-param-must-be-list"><a href="#insert-many-param-must-be-list" class="headerlink" title="insert_many param must be list"></a>insert_many param must be list</h1><p>collection.insert_many(mylist)</p><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><h1 id="find-one-just-show-meet-the-conditions-first-collection"><a href="#find-one-just-show-meet-the-conditions-first-collection" class="headerlink" title="find_one() just show meet the conditions first collection"></a>find_one() just show meet the conditions first collection</h1><h1 id="find-return-all-the-object-array-which-meet-the-conditions"><a href="#find-return-all-the-object-array-which-meet-the-conditions" class="headerlink" title="find() return all the object array which meet the conditions"></a>find() return all the object array which meet the conditions</h1><p>collection.find({“name”: “cursor”})[0]<br>collection.find({“name”: “cursor”})[1]</p><h1 id="use-for-in-operation-to-loop-all"><a href="#use-for-in-operation-to-loop-all" class="headerlink" title="use for-in operation to loop all"></a>use for-in operation to loop all</h1><p>for i in collection.find({“name”: “cursor”}):<br>    print(i)</p><h1 id="search-assign-conditions"><a href="#search-assign-conditions" class="headerlink" title="search assign conditions"></a>search assign conditions</h1><p>collection.find_one({“name”: “cursor”})<br>collection.find_one({“name”: “cursor”, “sex”: “female”})</p><h1 id="use-count"><a href="#use-count" class="headerlink" title="use .count()"></a>use .count()</h1><p>collection.find().count()  # this is equal to collection.count()<br>collection.find({“name”: “cursor”}).count()</p><h1 id="条件查询-lt-lt-gt-gt-lte-lt-gte-gt-ne"><a href="#条件查询-lt-lt-gt-gt-lte-lt-gte-gt-ne" class="headerlink" title="条件查询 $lt(&lt;) $gt(&gt;) $lte(&lt;=) $gte(&gt;=) #ne(!=)"></a>条件查询 $lt(&lt;) $gt(&gt;) $lte(&lt;=) $gte(&gt;=) #ne(!=)</h1><p>collection.find({“age”: {“$lt”: 30}})</p><h1 id="sort-the-find-result"><a href="#sort-the-find-result" class="headerlink" title="sort the find result"></a>sort the find result</h1><p>collection.find().sort(“age”)  # defult ASC<br>collection.find().sort(“age”, pymongo.ASCENDING)<br>collection.find().sort(“age”, pymongo.DESCENDING)</p><h1 id="查询-database中所有collection"><a href="#查询-database中所有collection" class="headerlink" title="查询 database中所有collection"></a>查询 database中所有collection</h1><p>db.collection_names()<br>db.collection_names(include_system_collections=False)  # 不包括系统collection，一般指的是system.indexes</p><h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><p>temp = collection.find_one({“name”: “Lucy”})<br>temp2 = temp.copy()<br>temp[“name”] = “Jordan”</p><h1 id="如果此时temp-“-id”-在该collection中已经存在，则-save-为更新操作，与-replace-one-作用相同，否则-save-为插入操作，与-insert-one-作用相同。"><a href="#如果此时temp-“-id”-在该collection中已经存在，则-save-为更新操作，与-replace-one-作用相同，否则-save-为插入操作，与-insert-one-作用相同。" class="headerlink" title="如果此时temp[“_id”]在该collection中已经存在，则.save()为更新操作，与 .replace_one() 作用相同，否则 .save() 为插入操作，与 .insert_one() 作用相同。"></a>如果此时temp[“_id”]在该collection中已经存在，则.save()为更新操作，与 .replace_one() 作用相同，否则 .save() 为插入操作，与 .insert_one() 作用相同。</h1><p>collection.save(temp)  # 或 .update() ，注意参数形式<br>collection.update(temp, temp2)  # 将temp更新为temp2</p><h1 id="还要注意的一点是，-replace-one-需要传入两个参数，分别为当前document和要更新为的-document-，与-update-相同"><a href="#还要注意的一点是，-replace-one-需要传入两个参数，分别为当前document和要更新为的-document-，与-update-相同" class="headerlink" title="还要注意的一点是，.replace_one()需要传入两个参数，分别为当前document和要更新为的 document ，与 .update() 相同"></a>还要注意的一点是，.replace_one()需要传入两个参数，分别为当前document和要更新为的 document ，与 .update() 相同</h1><h1 id="collection-replace-one-old-document-new-document"><a href="#collection-replace-one-old-document-new-document" class="headerlink" title="collection.replace_one(old_document, new_document)"></a>collection.replace_one(old_document, new_document)</h1><h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p>collection.remove(temp)  # 即便该temp不存在也不会报错<br>collection.delete_one(temp)<br>collection.delete_many(temp)  # 与 .insert_many() 不同，在temp不是list类型时也不会报错</p><h1 id="JSON序列化与反序列化"><a href="#JSON序列化与反序列化" class="headerlink" title="JSON序列化与反序列化"></a>JSON序列化与反序列化</h1><p>import json</p><h1 id="如果想序列化为标准-JSON-格式，两种方式，方式一，json-包中的-dumps："><a href="#如果想序列化为标准-JSON-格式，两种方式，方式一，json-包中的-dumps：" class="headerlink" title="如果想序列化为标准 JSON 格式，两种方式，方式一，json 包中的 dumps："></a>如果想序列化为标准 JSON 格式，两种方式，方式一，json 包中的 dumps：</h1><p>for i in collection.find({“name”: “cursor”}):<br>    del i[“_id”]  # 不能直接转换，无法识别ObjectId<br>    json.dumps(i)</p><h1 id="bson-json-util包中封装的-dumps："><a href="#bson-json-util包中封装的-dumps：" class="headerlink" title="bson.json_util包中封装的 dumps："></a>bson.json_util包中封装的 dumps：</h1><p>from bson import Binary, Code<br>from bson.json_util import dumps</p><p>dumps([{‘foo’: [1, 2]},<br>       {‘bar’: {‘hello’: ‘world’}},<br>       {‘code’: Code(“function x() { return1; }”)},<br>       {‘bin’: Binary(“”)}])</p><h1 id="‘-“foo”-1-2-“bar”-“hello”-”world”-“code”-“-code”-“function-x-return-1-”-“-scope”-“bin”-“-binary”-“”-“-type”-“00”-’"><a href="#‘-“foo”-1-2-“bar”-“hello”-”world”-“code”-“-code”-“function-x-return-1-”-“-scope”-“bin”-“-binary”-“”-“-type”-“00”-’" class="headerlink" title="‘[{“foo”: [1, 2]}, {“bar”: {“hello”:”world”}}, {“code”: {“$code”: “function x(){ return 1; }”, “$scope”: {}}}, {“bin”:{“$binary”: “”, “$type”: “00”}}]’"></a>‘[{“foo”: [1, 2]}, {“bar”: {“hello”:”world”}}, {“code”: {“$code”: “function x(){ return 1; }”, “$scope”: {}}}, {“bin”:{“$binary”: “”, “$type”: “00”}}]’</h1><h1 id="对应的反序列化方法为bson-json-util-loads"><a href="#对应的反序列化方法为bson-json-util-loads" class="headerlink" title="对应的反序列化方法为bson.json_util.loads()"></a>对应的反序列化方法为bson.json_util.loads()</h1>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSBridge解析</title>
      <link href="/2018/06/19/JSBridge%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/06/19/JSBridge%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="JS和Native之间的通信方式"><a href="#JS和Native之间的通信方式" class="headerlink" title="JS和Native之间的通信方式"></a>JS和Native之间的通信方式</h3><ul><li><p>在Android开发中，能实现Javascript与Native代码通信的，有4种途径：<br>1.JavascriptInterface<br>2.WebViewClient.shouldOverrideUrlLoading()<br>3.WebChromeClient.onConsoleMessage()<br>4.WebChromeClient.onJsPrompt()</p></li><li><p>Native调用Javascript使用loadUrl()方法。</p></li></ul><blockquote><p>此处涉及到了<a href="https://developer.android.com/reference/android/webkit/WebViewClient.html" target="_blank" rel="noopener">WebViewClient</a>和<a href="https://developer.android.com/reference/android/webkit/WebChromeClient.html" target="_blank" rel="noopener">WebChromeCLient</a>:</p></blockquote><blockquote><p>WebViewClient主要帮助WebView处理各种通知、请求事件的，比如：</p><ul><li>onPageStarted(WebView view, String url, Bitmap favicon)</li><li>onPageFinished(WebView view, String url)</li><li>onLoadResource(WebView view, String url)</li><li>onReceivedError(WebView view, int errorCode, String description, String failingUrl)</li><li>onReceivedHttpAuthRequest(WebView view,HttpAuthHandler handler, String host, String realm)</li><li>shouldOverrideUrlLoading(WebView view, String url)//将在webview上点击的url传递过来，java代码决定是否拦截</li></ul></blockquote><blockquote><p>WebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等比如</p><ul><li>onProgressChanged(WebView view, int newProgress)</li><li>onReceivedTitle(WebView view, String title)</li><li>onReceivedIcon(WebView view, Bitmap icon)</li><li>onJsAlert(WebView view, String url, String message,JsResult result)//JS需要弹出警告框</li><li>onJsConfirm(WebView view, String url, String message,JsResult result)//JS需要弹出确认框</li><li>onJsPrompt(WebView view, String url, String message,String defaultValue, JsPromptResult result)//JS需要弹出提示信息</li><li>onCloseWindow(WebView window)</li></ul></blockquote><hr><h3 id="JsBridge的实现"><a href="#JsBridge的实现" class="headerlink" title="JsBridge的实现"></a>JsBridge的实现</h3><p>JsBridge中，JAVA和JS互相调用前，都需要注册方法。</p><pre><code class="Java">//Native中注册方法，提供给JS调用（非webview原生方法，需要自定义）webView.registerHandler(&quot;submitFromWeb&quot;, new BridgeHandler() {    @Override    public void handler(String data, CallBackFunction function) {        Log.i(TAG, &quot;handler = submitFromWeb, data from web = &quot; + data);        function.onCallBack(&quot;submitFromWeb exe, response data 中文 from Java&quot;);    }});</code></pre><pre><code class="Javascript">//JS中注册方法，提供给Native调用bridge.registerHandler(&quot;functionInJs&quot;, function(data, responseCallback) {    document.getElementById(&quot;show&quot;).innerHTML = (&quot;data from Java: = &quot; + data);    var responseData = &quot;Javascript Says Right back aka!&quot;;    responseCallback(responseData);});</code></pre><hr><p>JAVA注册方法：<br>自定义webview调用registerHandler(String handlerName, BridgeHandler handler)后，将handler存入一个messageHandlers的Map中，键为handlerName，也就是JS调JAVA时需要指定的调用名称，handler就是JS调用JAVA是所执行的方法。</p><pre><code class="JAVA">//JAVA方面，webview进行方法注册public void registerHandler(String handlerName, BridgeHandler handler) {    if (handler != null) {        messageHandlers.put(handlerName, handler);    }}</code></pre><p>JS注册方法：<br>在将 WebViewJavascriptBridge.js 文件load到webview中后，JS中会执行connectWebViewJavascriptBridge方法，进行JS方面的调用方法注册。注册后，会将回调函数存储到messageHandlers这个对象中（可以理解为MAP，键为注册的函数名）。</p><pre><code class="javascript">//JS注册方法的形式，第一个参数是JAVA调用JS需要指定的方法名称，第二个函数参数是具体执行的方法。bridge.registerHandler(&quot;functionInJs&quot;, function(data, responseCallback) {})</code></pre><pre><code class="javascript">//注册实际调用的方法function registerHandler(handlerName, handler) {    messageHandlers[handlerName] = handler;}</code></pre><blockquote><p>此处建立WebViewJavascriptBridge.js和html界面的连接，有两种方法：</p><ul><li>在webview加载完html界面后（onPageFinished方法可以监听到），再次通过webview.loadUrl(“”)方法，将WebViewJavascriptBridge.js的加入到该webview中。</li><li>如果加载的是本地的（资源文件中的或者已经下载下来的）html界面，可以将WebViewJavascriptBridge.js添加到需要加载的界面的头部，再进行webview.loadDataWithBaseURL()或者webview.loadData()方法进行界面加载。<pre><code class="javascript">//WebViewJavascriptBridge.js中部分代码...//进行全局的参数申明，用于html界面判断是否已经进行了bridge的初始化var WebViewJavascriptBridge = window.WebViewJavascriptBridge = {  init: init,  send: send,  registerHandler: registerHandler,  callHandler: callHandler,  _fetchQueue: _fetchQueue,  _handleMessageFromNative: _handleMessageFromNative};var doc = document;_createQueueReadyIframe(doc);var readyEvent = doc.createEvent(&#39;Events&#39;);readyEvent.initEvent(&#39;WebViewJavascriptBridgeReady&#39;);//注册dom事件readyEvent.bridge = WebViewJavascriptBridge;doc.dispatchEvent(readyEvent);//发布事件...</code></pre><pre><code class="js">//加载的html界面中的部分代码...function connectWebViewJavascriptBridge(callback) {  if (window.WebViewJavascriptBridge) {//如果WebViewJavascriptBridge有定义，则直接执行回调函数      callback(WebViewJavascriptBridge)  } else {//WebViewJavascriptBridge没有定义，那么监听相关事件，等待激活      document.addEventListener(          &#39;WebViewJavascriptBridgeReady&#39;          , function() {              callback(WebViewJavascriptBridge)          },          false      );  }}//直接调用JS方法，传递回调函数connectWebViewJavascriptBridge(function(bridge) {  bridge.init(function(message, responseCallback) {      console.log(&#39;JS got a message&#39;, message);      var data = {          &#39;Javascript Responds&#39;: &#39;测试中文!&#39;      };      console.log(&#39;JS responding with&#39;, data);      responseCallback(data);  });  bridge.registerHandler(&quot;functionInJs&quot;, function(data, responseCallback) {      document.getElementById(&quot;show&quot;).innerHTML = (&quot;data from Java: = &quot; + data);      var responseData = &quot;Javascript Says Right back aka!&quot;;      responseCallback(responseData);  });})...</code></pre></li></ul></blockquote><h3 id="JAVA调用JS方法"><a href="#JAVA调用JS方法" class="headerlink" title="JAVA调用JS方法"></a>JAVA调用JS方法</h3><p>一般来讲，JAVA调用JS使用callHandler(String handlerName, String data, CallBackFunction callBack)方法，也可以使用send(String data)方法进行默认方法（需要在JS调用端进行处理）的调用。</p><pre><code class="JAVA">//BridgeWebView部分代码...//此方法为调用JS方法最终会调用到的方法//参数：handlerName-JS注册的方法名称；data-传递的数据；responseCallback-调用成功后的回调函数private void doSend(String handlerName, String data, CallBackFunction responseCallback) {    Message m = new Message();    if (!TextUtils.isEmpty(data)) {        m.setData(data);    }    if (responseCallback != null) {        String callbackStr = String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));        responseCallbacks.put(callbackStr, responseCallback);        m.setCallbackId(callbackStr);    }    if (!TextUtils.isEmpty(handlerName)) {        m.setHandlerName(handlerName);    }    queueMessage(m);}private void queueMessage(Message m) {    if (startupMessage != null) {        startupMessage.add(m);    } else {        dispatchMessage(m);    }}void dispatchMessage(Message m) {    String messageJson = m.toJson();    //escape special characters for json string    messageJson = messageJson.replaceAll(&quot;(\\\\)([^utrn])&quot;, &quot;\\\\\\\\$1$2&quot;);    messageJson = messageJson.replaceAll(&quot;(?&lt;=[^\\\\])(\&quot;)&quot;, &quot;\\\\\&quot;&quot;);    String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);    if (Thread.currentThread() == Looper.getMainLooper().getThread()) {        this.loadUrl(javascriptCommand);    }}...</code></pre><p>Message类的定义</p><pre><code class="JAVA">//用于在JAVA和JS之间通讯的重要类public class Message {    private String callbackId; //回调函数的唯一确认值    private String responseId; //responseId    private String responseData; //responseData    private String data; //传递的数据    private String handlerName; //调用函数注册的名称    //一些数据转化需要的数据标识符    private final static String CALLBACK_ID_STR = &quot;callbackId&quot;;    private final static String RESPONSE_ID_STR = &quot;responseId&quot;;    private final static String RESPONSE_DATA_STR = &quot;responseData&quot;;    private final static String DATA_STR = &quot;data&quot;;    private final static String HANDLER_NAME_STR = &quot;handlerName&quot;;        ...set and gets...    //将message类实例转化为json对象    public String toJson() {        JSONObject jsonObject= new JSONObject();        try {            jsonObject.put(CALLBACK_ID_STR, getCallbackId());            jsonObject.put(DATA_STR, getData());            jsonObject.put(HANDLER_NAME_STR, getHandlerName());            jsonObject.put(RESPONSE_DATA_STR, getResponseData());            jsonObject.put(RESPONSE_ID_STR, getResponseId());            return jsonObject.toString();        } catch (JSONException e) {            e.printStackTrace();        }        return null;    }    //将message类对应的json对象转化为message类实例    public static Message toObject(String jsonStr) {        Message m =  new Message();        try {            JSONObject jsonObject = new JSONObject(jsonStr);            m.setHandlerName(jsonObject.has(HANDLER_NAME_STR) ? jsonObject.getString(HANDLER_NAME_STR):null);            m.setCallbackId(jsonObject.has(CALLBACK_ID_STR) ? jsonObject.getString(CALLBACK_ID_STR):null);            m.setResponseData(jsonObject.has(RESPONSE_DATA_STR) ? jsonObject.getString(RESPONSE_DATA_STR):null);            m.setResponseId(jsonObject.has(RESPONSE_ID_STR) ? jsonObject.getString(RESPONSE_ID_STR):null);            m.setData(jsonObject.has(DATA_STR) ? jsonObject.getString(DATA_STR):null);            return m;        } catch (JSONException e) {            e.printStackTrace();        }        return m;    }    public static List&lt;Message&gt; toArrayList(String jsonStr){        List&lt;Message&gt; list = new ArrayList&lt;Message&gt;();        try {            JSONArray jsonArray = new JSONArray(jsonStr);            for(int i = 0; i &lt; jsonArray.length(); i++){                Message m = new Message();                JSONObject jsonObject = jsonArray.getJSONObject(i);                m.setHandlerName(jsonObject.has(HANDLER_NAME_STR) ? jsonObject.getString(HANDLER_NAME_STR):null);                m.setCallbackId(jsonObject.has(CALLBACK_ID_STR) ? jsonObject.getString(CALLBACK_ID_STR):null);                m.setResponseData(jsonObject.has(RESPONSE_DATA_STR) ? jsonObject.getString(RESPONSE_DATA_STR):null);                m.setResponseId(jsonObject.has(RESPONSE_ID_STR) ? jsonObject.getString(RESPONSE_ID_STR):null);                m.setData(jsonObject.has(DATA_STR) ? jsonObject.getString(DATA_STR):null);                list.add(m);            }        } catch (JSONException e) {            e.printStackTrace();        }        return list;    }}</code></pre><h3 id="JS调用JAVA方法"><a href="#JS调用JAVA方法" class="headerlink" title="JS调用JAVA方法"></a>JS调用JAVA方法</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></p><blockquote><p>参考：<a href="http://www.cnblogs.com/wingyip/p/5426477.html" target="_blank" rel="noopener">http://www.cnblogs.com/wingyip/p/5426477.html</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JSBridge </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQLite</title>
      <link href="/2018/06/19/SQLite/"/>
      <url>/2018/06/19/SQLite/</url>
      <content type="html"><![CDATA[<h1 id="SQLite-基础知识"><a href="#SQLite-基础知识" class="headerlink" title="SQLite 基础知识"></a>SQLite 基础知识</h1><p><a href="https://www.sqlite.org" target="_blank" rel="noopener">SQLite</a></p><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><p>sqlite中不支持删除列的操作，也不能够修改主键。<br><img src="https://www.sqlite.org/images/syntax/alter-table-stmt.gif" alt="ALTER TABLE操作"><br>从上图可见，SQLite官方并不支持delete或者drop列。</p><blockquote><p><a href="https://www.sqlite.org/lang_altertable.html" target="_blank" rel="noopener">SQLite supports a limited subset of ALTER TABLE. The ALTER TABLE command in SQLite allows the user to rename a table or to add a new column to an existing table.</a></p></blockquote><p>那么在SQLite中，如果需要删除某一列或者更改表的主码，需要使用创建临时表的方式进行。创建一张表结构正确的临时表，并将原表中的数据转移过去，再删除原表，重命名临时表为正确表名。下面是一个Java的例子：</p><pre><code class="java">List&lt;String&gt; sqls = new ArrayList&lt;&gt;();if (isTableExist(dbManager, &quot;XX&quot;)) {  sqls.add(&quot;CREATE TABLE \&quot;XX_tmp\&quot; (\&quot;arg0\&quot; TEXT ,\&quot;arg1\&quot; TEXT ,\&quot;arg2\&quot; TEXT ,\&quot;arg3\&quot; TEXT ,\&quot;arg4\&quot; TEXT PRIMARY KEY ,\&quot;attflag\&quot; TEXT ,\&quot;attmsg\&quot; TEXT );&quot;);   sqls.add(&quot;INSERT INTO XX_tmp SELECT * FROM XX;&quot;);  sqls.add(&quot;DROP TABLE XX;&quot;);  sqls.add(&quot;ALTER TABLE XX_tmp RENAME TO XX;&quot;);  dbManager.getDatabase().beginTransaction();  for (String sql : sqls)    dbManager.execNonQuery(sql);  dbManager.getDatabase().endTransaction();  U.L.d(TAG, &quot;用户数据库第一次升级完成：修改XX表的主键！&quot;);}</code></pre><h2 id="PRAGMA-Statements"><a href="#PRAGMA-Statements" class="headerlink" title="PRAGMA Statements"></a><a href="https://www.sqlite.org/pragma.html" target="_blank" rel="noopener">PRAGMA Statements</a></h2><p>SQLite 的 <strong>PRAGMA</strong> 命令是一个特殊的命令，可以用在 SQLite 环境内控制各种环境变量和状态标志。</p><h2 id="sqlite-master"><a href="#sqlite-master" class="headerlink" title="sqlite_master"></a>sqlite_master</h2><p>SQLite数据库中一个特殊的名叫 SQLITE_MASTER 上执行一个SELECT查询以获得所有表的索引。每一个 SQLite 数据库都有一个叫 SQLITE_MASTER 的表， 它定义数据库的模式。</p><p>type值为table表示对应的是表记录，type值为index表示对应的是索引的记录。<br>最后一栏列名为“sql”，存储的是创建表或者索引时的原始sql命令。如果index是自动生成的，那么sql为空。<br>sqlite_master表是只读表，不能手工进行内容修改。</p><p><img src="http://upload-images.jianshu.io/upload_images/1342270-496b1a0eb42316f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sqlite_master.png"></p><p>查询数据库中是否存在某张表，或者查询数据库中所有的表可用如下方式：</p><pre><code class="sql">--查询是否存在table_name这张表，实际上是查询有几个table_name表名存在，返回0则不存在，1则存在。SELECT count(*) AS cFROM sqlite_masterWHERE TYPE =&#39;table&#39;  AND name =&#39;table_name&#39;;--查询数据库中所有的表SELECT name AS TABLE_NAMEFROM sqlite_masterWHERE TYPE=&#39;table&#39;;</code></pre><p>上面用到的isTableExist(DbManager dbManager, String tableName)方法如下：</p><pre><code class="java">//判断表是否存在protected final boolean isTableExist(DbManager dbManager, String tableName) {    boolean isExist = false;    String sql = &quot;SELECT COUNT(*) AS c FROM sqlite_master WHERE TYPE =&#39;table&#39; AND NAME =&#39;&quot; + tableName + &quot;&#39;;&quot;;    try {        Cursor mCursor = dbManager.execQuery(sql);        if (mCursor.moveToNext()) {            int count = mCursor.getInt(0);            if (count &gt; 0) {                isExist = true;            }        }    } catch (DbException e) {        e.printStackTrace();    }    return isExist;}</code></pre><p>临时表不会出现在 SQLITE_MASTER 表中。临时表及其索引和触发器存放在另外一个叫 SQLITE_TEMP_MASTER 的表中。SQLITE_TEMP_MASTER 跟 SQLITE_MASTER 差不多， 但它只是对于创建那些临时表的应用可见。如果要获得所有表的列表， 不管是永久的还是临时的，可以使用类似下面的命令：</p><pre><code class="sql">SELECT nameFROM  (SELECT *   FROM sqlite_master   UNION ALL SELECT *   FROM sqlite_temp_master)WHERE TYPE=’TABLE’</code></pre><h2 id="SQLite-表复制"><a href="#SQLite-表复制" class="headerlink" title="SQLite 表复制"></a>SQLite 表复制</h2><ul><li><p>复制整张表，包括表里面的数据。</p><pre><code class="sql">CREATE TABLE affix_backup AS SELECT * FROM affix;</code></pre></li><li><p>只复制表结构，不复制内容。</p><pre><code class="sql">CREATE TABLE affix_backup AS SELECT * FROM affix where 1=0;</code></pre></li><li><p>内容复制（SQLite不支持第一种）。</p><pre><code class="sql">--把数据插入一张新建立的表中，这张表是执行sql的时候建立的。SELECT ... INTO new_tablenameFROM ...WHERE ...--或者--把查询出来的数据插入已经建立好的表中INSERT INTO tmp_tablenameSELECT ...FROM ...WHERE ...</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android应用获取手机的虚拟机类型</title>
      <link href="/2018/06/19/Android%E5%BA%94%E7%94%A8%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/06/19/Android%E5%BA%94%E7%94%A8%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="ART-and-Dalvik"><a href="#ART-and-Dalvik" class="headerlink" title="ART and Dalvik"></a><a href="https://source.android.com/devices/tech/dalvik/index.html" target="_blank" rel="noopener">ART and Dalvik</a></h3><p><strong>Dalvik虚拟机</strong>，是<a href="https://zh.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>等厂商合作开发的<a href="https://zh.wikipedia.org/wiki/Android" target="_blank" rel="noopener">Android</a>移动设备平台的核心组成部分之一。它可以支持已转换为.dex（即“Dalvik Executable”）格式的<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a>应用程序的运行。.dex格式是专为Dalvik设计的一种压缩格式，适合<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" target="_blank" rel="noopener">内存</a>和<a href="https://zh.wikipedia.org/wiki/%E5%A4%84%E7%90%86%E5%99%A8" target="_blank" rel="noopener">处理器</a>速度有限的系统。</p><p>大多数<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">虚拟机</a>包括<a href="https://zh.wikipedia.org/wiki/JVM" target="_blank" rel="noopener">JVM</a>都是一种<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%A9%9F%E5%99%A8" target="_blank" rel="noopener">堆栈机器</a>，而Dalvik虚拟机则是<a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA" target="_blank" rel="noopener">寄存器机</a>。两种架构各有优劣，一般而言，基于堆栈的机器需要更多指令，而基于寄存器的机器指令更长。</p><p>从<a href="https://zh.wikipedia.org/wiki/Android_5.0" target="_blank" rel="noopener">Android 5.0</a>版起，<a href="https://zh.wikipedia.org/wiki/Android_Runtime" target="_blank" rel="noopener">Android Runtime</a>（ART）替换Dalvik成为系统内默认虚拟机。（这不代表你的手机用的6.0系统，使用的就是ART虚拟机，国产Android系统中很多升级为6.0系统的任然使用的是Dalvik）</p><p><strong>Android Runtime</strong>（缩写为ART），是一种在<a href="https://zh.wikipedia.org/wiki/Android" target="_blank" rel="noopener">Android</a>操作系统上的<a href="https://zh.wikipedia.org/wiki/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">运行环境</a>，由<a href="https://zh.wikipedia.org/wiki/Google%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">Google公司</a>研发，并在2013年作为<a href="https://zh.wikipedia.org/wiki/Android_4.4" target="_blank" rel="noopener">Android 4.4</a>系统中的一项测试功能正式对外发布，在<a href="https://zh.wikipedia.org/wiki/Android_5.0" target="_blank" rel="noopener">Android 5.0</a>及后续Android版本中作为正式的运行时库取代了以往的<a href="https://zh.wikipedia.org/wiki/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">Dalvik虚拟机</a>。ART能够把应用程序的<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81" target="_blank" rel="noopener">字节码</a>转换为<a href="https://zh.wikipedia.org/wiki/%E6%A9%9F%E5%99%A8%E7%A2%BC" target="_blank" rel="noopener">机器码</a>，是Android所使用的一种新的<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">虚拟机</a>。它与Dalvik的主要不同在于：Dalvik采用的是<a href="https://zh.wikipedia.org/wiki/JIT" target="_blank" rel="noopener">JIT</a>技术，而ART采用<a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation" target="_blank" rel="noopener">Ahead-of-time</a>（AOT）技术。ART同时也改善了性能、<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">垃圾回收</a>)（Garbage Collection）、应用程序除错以及性能分析。</p><p><img src="http://upload-images.jianshu.io/upload_images/1342270-f518ccbc7737198a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dalvik虚拟机和ART原理的对比"></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code class="java">public CharSequence getCurrentRuntimeValue() {        String SELECT_RUNTIME_PROPERTY = &quot;persist.sys.dalvik.vm.lib&quot;;        String LIB_DALVIK = &quot;libdvm.so&quot;;        String LIB_ART = &quot;libart.so&quot;;        String LIB_ART_D = &quot;libartd.so&quot;;        try {            Class&lt;?&gt; systemProperties = Class.forName(&quot;android.os.SystemProperties&quot;);            try {                Method get = systemProperties.getMethod(&quot;get&quot;,                        String.class, String.class);                if (get == null) {                    return &quot;未获取到&quot;;                }                try {                    final String value = (String) get.invoke(                            systemProperties, SELECT_RUNTIME_PROPERTY,                        /* Assuming default is */&quot;Dalvik&quot;);                    if (LIB_DALVIK.equals(value)) {                        return &quot;Dalvik&quot;;                    } else if (LIB_ART.equals(value)) {                        return &quot;ART&quot;;                    } else if (LIB_ART_D.equals(value)) {                        return &quot;ART debug build&quot;;                    }                    return value;                } catch (IllegalAccessException e) {                    return &quot;IllegalAccessException&quot;;                } catch (IllegalArgumentException e) {                    return &quot;IllegalArgumentException&quot;;                } catch (InvocationTargetException e) {                    return &quot;InvocationTargetException&quot;;                }            } catch (NoSuchMethodException e) {                return &quot;SystemProperties.get(String key, String def) method is not found&quot;;            }        } catch (ClassNotFoundException e) {            return &quot;SystemProperties class is not found&quot;;        }    }</code></pre><blockquote><p>代码参考自：<a href="http://stackoverflow.com/questions/19830342/how-can-i-detect-the-android-runtime-dalvik-or-art" target="_blank" rel="noopener">http://stackoverflow.com/questions/19830342/how-can-i-detect-the-android-runtime-dalvik-or-art</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux抓包软件之：BurpSuite</title>
      <link href="/2018/06/19/Linux%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E4%B9%8B%EF%BC%9ABurpSuite/"/>
      <url>/2018/06/19/Linux%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E4%B9%8B%EF%BC%9ABurpSuite/</url>
      <content type="html"><![CDATA[<h3 id="burp-suite官网地址"><a href="#burp-suite官网地址" class="headerlink" title="burp suite官网地址"></a>burp suite官网地址</h3><p><a href="https://portswigger.net" target="_blank" rel="noopener">burp suite</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h4><p>在官网下载界面选择免费版或者付费版进行下载：<br><a href="https://portswigger.net/burp/download.html" target="_blank" rel="noopener">官网下载地址</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1342270-75e32bdf4f732087.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="软件下载界面"></p><h4 id="2-开启软件"><a href="#2-开启软件" class="headerlink" title="2.开启软件"></a>2.开启软件</h4><p>由于burp suite是使用Java编写的，所以使用burp suite需要Java环境的支持，关于如何弄Java环境，自行百度。</p><p>官网建议在开启软件的时候进行java虚拟机内存设置，在终端中输入以下命令打开软件：</p><pre><code class="java">//分配了2G的虚拟机内存，后面为下载的文件名称java -jar -Xmx2G burpsuite_free_v1.7.03.jar</code></pre><h4 id="3-浏览器抓包"><a href="#3-浏览器抓包" class="headerlink" title="3.浏览器抓包"></a>3.浏览器抓包</h4><h5 id="配置软件监听的端口"><a href="#配置软件监听的端口" class="headerlink" title="配置软件监听的端口"></a>配置软件监听的端口</h5><ul><li>选中 proxy 第一级选项卡，再选择 Options 第二级选项卡，先看 Proxy Listeners 部分，确保 “127.0.0.1:8080” 端口条目前面的多选按钮是勾选上的。</li><li>然后在浏览器上进行设置，使浏览器的 HTTP Proxy 经过 127.0.0.1:8080端口即可；</li></ul><h4 id="4-手机抓包"><a href="#4-手机抓包" class="headerlink" title="4.手机抓包"></a>4.手机抓包</h4><ul><li>在 proxy 的 proxy listeners中讲监听的地址修改为所有地址；</li><li>在手机端设置网络代理（手机和电脑需在同一网段）代理服务器地址就是电脑的局域网地址，端口就是设置监听的端口；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1342270-4a8b3621e64b80ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置监听端口"></p><ul><li>完成设置后，在手机端发起网络请求，就会经过burp suite了。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1342270-17f5c07cf71f61b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="抓包列表"></p><p>如果是POST请求，那么可以勾选上params显示请求的参数。并且，这个和 windows 的fillder 不一样，如果是同一个 host 的请求，在左侧列表中只显示一个，选中左侧 host 后，会在右侧出现这个 host 的所有请求，并且按照时间先后从上往下排列。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> BurpSuite </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github上传代码</title>
      <link href="/2018/06/19/github%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/"/>
      <url>/2018/06/19/github%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<h2 id="0-开头"><a href="#0-开头" class="headerlink" title="0.开头"></a>0.开头</h2><p>在github上注册账号并简历仓库后，上传本地数据前需要配置SSH，SSH用于进行身份认证（git是分布式的代码管理工具，远程代码管理是基于ssh的，所以使用远程的git需要ssh的配置）。</p><blockquote><p>关于windows：<br>如果你使用的是windows系统，建议使用 <a href="https://windows.github.com/" target="_blank" rel="noopener">GitHub for Windows</a> ，安装这个软件也会附带Git Bash工具，并且比通过 git 命令进行版本管理方便的多。</p></blockquote><h2 id="1-git配置"><a href="#1-git配置" class="headerlink" title="1.git配置"></a>1.git配置</h2><p>windows用户需要下载安装Git Bash，linux通过终端安装git。安装完后对git进行配置（配置过的用户可以通过git –lis命令查看配置）：</p><pre><code>$ git config --global user.name &quot;xxx&quot;$ git config --global user.email &quot;xxx@abc.com&quot;</code></pre><h2 id="2-SSH生成"><a href="#2-SSH生成" class="headerlink" title="2.SSH生成"></a>2.SSH生成</h2><p>在Git Bash或者终端中，输入以下代码，用你的github邮箱替换其中的邮箱地址：</p><pre><code>ssh-keygen -t rsa -b 4096 -C &quot;*your_email@example.com*&quot;# Creates a new ssh key, using the provided email as a labelGenerating public/private rsa key pair.</code></pre><p>当界面提示：”Enter a file in which to save the key,”时，直接回车使用默认存储地址（默认地址为：～/.ssh）：</p><pre><code>Enter a file in which to save the key (/Users/*you*/.ssh/id_rsa): *[Press enter]*</code></pre><p>然后提示输入密码和确认密码，此处可以按回车跳过。</p><pre><code>Enter passphrase (empty for no passphrase): *[Type a passphrase]*Enter same passphrase again: *[Type passphrase again]*</code></pre><p>然后可以看见提示，ssh生成到此完成。</p><pre><code>Your identification has been saved in /home/&lt;user&gt;/.ssh/id_rsa.Your public key has been saved in /home/&lt;user&gt;/.ssh/id_rsa.pub.The key fingerprint is:SHA256:********** &lt;youemail&gt;@123.comThe key&#39;s randomart image is:******</code></pre><p>ssh生成完成后会在～/.ssh文件夹看到两个文件（默认存储路径时）：</p><p><img src="http://upload-images.jianshu.io/upload_images/1342270-48837db9243428aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="默认ssh路径下"></p><h2 id="3-添加SSH-key到ssh-agent"><a href="#3-添加SSH-key到ssh-agent" class="headerlink" title="3.添加SSH key到ssh-agent"></a>3.添加SSH key到ssh-agent</h2><p>确定ssh-agent是否可用：</p><ul><li>如果你使用Git Bash或者终端，键入如下命令打开ssh-agent：</li></ul><pre><code>  # start the ssh-agent in the background  $ eval &quot;$(ssh-agent -s)&quot;  Agent pid 59566</code></pre><ul><li>如果你使用其他的终端，例如<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">Git for Windows</a>，请键入如下命令打开ssh-agent：</li></ul><pre><code># start the ssh-agent in the background$ eval $(ssh-agent -s)Agent pid 59566</code></pre><p>将SSH key添加到ssh-agent：</p><pre><code>$ ssh-add ~/.ssh/id_rsa</code></pre><h2 id="4-在你的gitbug账户中添加一个新的SSH-key"><a href="#4-在你的gitbug账户中添加一个新的SSH-key" class="headerlink" title="4.在你的gitbug账户中添加一个新的SSH key"></a>4.在你的gitbug账户中添加一个新的SSH key</h2><p>拷贝SSH key：</p><ul><li>通过xclip拷贝，在终端中执行以下命令：</li></ul><pre><code>$ sudo apt-get install xclip# Downloads and installs xclip. If you don&#39;t have `apt-get`, you might need to use another installer (like `yum`)$ xclip -sel clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard</code></pre><ul><li>直接拷贝。通过编辑器打开id_rsa.pub，或者通过cat等命令直接查看id_rsa.pub文件，并且选中内容拷贝。</li></ul><p>在你的github主页选择<strong>Settings</strong>-&gt;<strong>SSH and GPG keys</strong>-&gt;<strong>New SSH key</strong> or <strong>Add SSH key</strong><br>在title中输入这个ssh key的名称，用于自己辨识。在key中粘贴刚刚复制的数据。<br>然后点击<strong>Add SSH key</strong>，进行github密码验证后即可添加成功。</p><h2 id="5-git常用操作"><a href="#5-git常用操作" class="headerlink" title="5.git常用操作"></a>5.git常用操作</h2><ul><li>git init //初始化，在此文件夹中建立空的git库</li><li>git clone url //同步远程的库</li><li>git add . //添加所有修改过的文件（仅添加，未上传，或者说未保存到本地库）</li><li>git commit -m “说明” //真正的上传文件（保存到本地库）</li><li>git remote add origin url //远程上传到指定地址</li><li>git push -u origin master    //上传到远程库</li></ul>]]></content>
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android的Material-Design初次尝试</title>
      <link href="/2018/06/19/Android%E7%9A%84Material-Design%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95%E3%80%82/"/>
      <url>/2018/06/19/Android%E7%9A%84Material-Design%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95%E3%80%82/</url>
      <content type="html"><![CDATA[<p>Android 的 Material Design 初次尝试。</p><h2 id="抽屉导航"><a href="#抽屉导航" class="headerlink" title="抽屉导航"></a>抽屉导航</h2><p>android.support.v4.widget.DrawerLayout 抽屉控件，他下面包含两大块，第一块为主屏幕显示的布局，第二块为抽屉布局。</p><pre><code class="java">tools:openDrawer=&quot;start&quot;//在布局中可以用这个属性控制抽屉布局显示出来</code></pre><p>可以通过以下操作对DrawerLayout进行操作：</p><pre><code class="java">mDrawerLayout.openDrawer(GravityCompat.START);//开启抽屉，这里的方向应该和NavigationView的layout_gravity相同mDrawerLayout.closeDrawers();//关闭抽屉</code></pre><h2 id="NavigationView"><a href="#NavigationView" class="headerlink" title="NavigationView"></a>NavigationView</h2><p>全类名：android.support.design.widget.NavigationView 。我们需要导入design包。</p><blockquote><p>compile ‘com.android.support:design:23.4.0’</p></blockquote><p>在Material Design中，Navigation drawer 导航抽屉，被设计用于应用的导航菜单，作为一种可默认隐藏，通过手势或者按钮拖出来的导航菜单。<br>NavigationView 的典型用途就是配合 DrawerLayout 作为体重的导航菜单的内容部分。NavigationView 是一个导航菜单的框架，使用 menu 资源填充菜单数据项，可以简单快捷的实现一个风格统一的导航菜单。NavigationView有一些配置如下：</p><pre><code class="java">android:layout_gravity=&quot;start&quot;//设置菜单方位，start为左边拖拽出来，end为右边拖拽出来app:headerLayout=&quot;@layout/nev_header&quot;//设置菜单的header部分布局app:menu=&quot;@menu/drawer_actions&quot;//设置菜单项android:fitsSystemWindows=&quot;true&quot;</code></pre><p>通过以上设置，就能够在主屏幕的左边拖拽出导航菜单啦。</p><p>典型的布局代码如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout    android:id=&quot;@+id/drawer_layout&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:openDrawer=&quot;start&quot;&gt;    &lt;!--Content--&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;android.support.design.widget.AppBarLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;android.support.v7.widget.Toolbar                android:id=&quot;@+id/toolbar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;&gt;            &lt;/android.support.v7.widget.Toolbar&gt;        &lt;/android.support.design.widget.AppBarLayout&gt;        &lt;FrameLayout            android:id=&quot;@+id/fl_content&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;        &lt;/FrameLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--Drawer Navigation--&gt;    &lt;android.support.design.widget.NavigationView        android:id=&quot;@+id/nav_view&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_gravity=&quot;start&quot;        android:fitsSystemWindows=&quot;true&quot;        app:headerLayout=&quot;@layout/nev_header&quot;        app:menu=&quot;@menu/drawer_actions&quot;&gt;    &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt;</code></pre><h2 id="Toolbars"><a href="#Toolbars" class="headerlink" title="Toolbars"></a>Toolbars</h2><p>全类名：android.support.v7.widget.Toolbar</p><p><a href="http://www.google.com/design/spec/layout/structure.html#structure-toolbars" target="_blank" rel="noopener">说明</a>：</p><blockquote><p>Toolbars are versatile and can be used in many different ways.</p></blockquote><p>Toolbar 的使用：</p><pre><code class="java">Toolbar mToolbar = (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(mToolbar);ActionBar ab = getSupportActionBar();ab.setHomeAsUpIndicator(R.drawable.ic_menu);//设置home图标是否显示ab.setDisplayHomeAsUpEnabled(true);</code></pre><h2 id="AppBarLayout"><a href="#AppBarLayout" class="headerlink" title="AppBarLayout"></a>AppBarLayout</h2><p>全类名：android.support.design.widget.AppBarLayout</p><p><a href="http://www.google.com/design/spec/layout/structure.html#structure-toolbars" target="_blank" rel="noopener">说明</a>：</p><blockquote><p>The app bar, formerly known as the action bar in Android, is a special kind of toolbar that’s used for branding, navigation, search, and actions.</p></blockquote><blockquote><p>AppBar 即以前我们称之为的 ActionBar，是一种用来展示信息、界面导航、搜索以及其他操作的一种特殊的工具栏。</p></blockquote><blockquote><p>The nav icon at the left side of the app bar can be:</p><pre><code>- A control to open a navigation drawer.- An up arrow for navigating upward through your app’s hierarchy.- Omitted entirely if no navigation is required from this screen.- The title in the app bar reflects the current page. It can be an app title, page title, or a page filter.</code></pre></blockquote><blockquote><p>Icons on the right side of the app bar are app-related actions. The menu icon opens the overflow menu, which contains secondary actions and menu items like help, settings, and feedback.</p></blockquote>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 的 MVP 模式浅尝</title>
      <link href="/2018/06/19/Android%E7%9A%84MVP%E6%A8%A1%E5%BC%8F%E6%B5%85%E5%B0%9D/"/>
      <url>/2018/06/19/Android%E7%9A%84MVP%E6%A8%A1%E5%BC%8F%E6%B5%85%E5%B0%9D/</url>
      <content type="html"><![CDATA[<p>Android 的 MVP 模式浅尝。</p><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h2><p>负责所有业务数据操作的实现。<br>创建的时候把相应的 View 也传递过来，在 View 中实现 setPresenter(Presenter presenter) 类似接口，在 presenter 中将自身设置给 View。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>负责展示给用户的显示UI。<br>通过实现 setPresenter(Presenter presenter) 接口得到对 Presenter的引用，在界面 UI 发生点击等事件后，调用相应的 presenter 的方法实现数据获取，presenter 在获取到数据后，会调用自身引用的 View 的相应的展示数据的方法进行UI响应。</p><h2 id="Contract类"><a href="#Contract类" class="headerlink" title="Contract类"></a>Contract类</h2><p>由于 View 和 Presenter 都互相持有对方的引用，并且每一个 View 也就是我们应用的每一个界面，他们的数据操作都有所不同，所以为了方便管理，同一个界面的 View 和 Presenter 应该有一个方法的约束类。<br>也就是说：每一个 View 能够执行的操作是固定了的，那么相对应的 Presenter 的方法也是相对固定的。例如：一个管理 task 的界面，他的 contract 类可以做成如下：</p><pre><code class="java">public interface TasksContract {    //task这个 View 能够执行的 UI 层面的操作方法    interface View extends BaseView&lt;Presenter&gt; {        void setLoadingIndicator(boolean active);        void showTasks(List&lt;Task&gt; tasks);        void showAddTask();        void showTaskDetailsUi(String taskId);        void showTaskMarkedComplete();        void showTaskMarkedActive();        void showCompletedTasksCleared();        void showLoadingTasksError();        void showNoTasks();        void showActiveFilterLabel();        void showCompletedFilterLabel();        void showAllFilterLabel();        void showNoActiveTasks();        void showNoCompletedTasks();        void showSuccessfullySavedMessage();        boolean isActive();        void showFilteringPopUpMenu();    }    //task 这个 View UI 的方法需要调用的数据解析类的方法    interface Presenter extends BasePresenter {        void result(int requestCode, int resultCode);        void loadTasks(boolean forceUpdate);        void addNewTask();        void openTaskDetails(@NonNull Task requestedTask);        void completeTask(@NonNull Task completedTask);        void activateTask(@NonNull Task activeTask);        void clearCompletedTasks();        void setFiltering(TasksFilterType requestType);        TasksFilterType getFiltering();    }}</code></pre><p>其中接口 BaseView 定义了所有的 View 类都必须实现的基础方法：</p><pre><code class="java">public interface BaseView&lt;T&gt; {    void setPresenter(T presenter);}</code></pre><p>同样接口 BasePresenter 定义了所有的 Presenter 都必须实现的基础方法：</p><pre><code class="java">public interface BasePresenter {    void start();}</code></pre>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EditText中onEditorAction监听事件执行两次</title>
      <link href="/2018/06/19/EditText%E4%B8%ADonEditorAction%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E4%B8%A4%E6%AC%A1/"/>
      <url>/2018/06/19/EditText%E4%B8%ADonEditorAction%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E4%B8%A4%E6%AC%A1/</url>
      <content type="html"><![CDATA[<p>Android的EditText通过setOnEditorActionListener给文本编辑框设置监听事件，但是在其处理方法onEditorAction中的逻辑在每次回车后都触发了两次，原来是在键盘回车的ACTION_UP和ACTION_DOWN时都会触发这个方法，因此修改代码如下，就防止了两次执行：</p><pre><code class="java">public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {        //以下方法防止两次发送请求        if (actionId == EditorInfo.IME_ACTION_SEND ||                (event != null &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_ENTER)) {            switch (event.getAction()) {                case KeyEvent.ACTION_UP:                    //发送请求                    String keyWord = et_search.getText().toString().trim();                    if (null == keyWord)                        keyWord = &quot;&quot;;                    dismisspopup();                    LogUtils.d(&quot;向服务器发送搜索请求：&quot; + keyWord);                    //发起查询                    searchByKeyWord(keyWord);                    hideSoftInput();                    return true;                default:                    return true;            }        }        return false;    }</code></pre>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> EditText </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fragment的getChildFragmentManager与getFragmentManager方法</title>
      <link href="/2018/06/19/Fragment%E7%9A%84getChildFragmentManager%E4%B8%8EgetFragmentManager%E6%96%B9%E6%B3%95/"/>
      <url>/2018/06/19/Fragment%E7%9A%84getChildFragmentManager%E4%B8%8EgetFragmentManager%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h2><p>这次项目中采用了在fragment中添加了一个viewpager的形式，viewpager中切换的是fragment。</p><h2 id="BUG："><a href="#BUG：" class="headerlink" title="BUG："></a>BUG：</h2><p>退出了那个包含viewpager的fragment并重新进入，切换viewpager时，不调用fragmentpageradapter适配器的getItem()方法，在显示上，出现viewpager的显示数量增多、显示数据不正确（这个情况只在初始化fragment时，需要传递参数的情况）的情况。</p><h2 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h2><p>fragmentpageradapter的instantiateItem(ViewGroup container, int position)方法，在调用的时候做了优化处理：</p><pre><code class="java">public Object instantiateItem(ViewGroup container, int position) {    if (mCurTransaction == null) {        mCurTransaction = mFragmentManager.beginTransaction();    }    final long itemId = getItemId(position);    // Do we already have this fragment?    String name = makeFragmentName(container.getId(), itemId);    Fragment fragment = mFragmentManager.findFragmentByTag(name);    if (fragment != null) {        if (DEBUG) Log.v(TAG, &quot;Attaching item #&quot; + itemId + &quot;: f=&quot; + fragment);        mCurTransaction.attach(fragment);    } else {        fragment = getItem(position);        if (DEBUG) Log.v(TAG, &quot;Adding item #&quot; + itemId + &quot;: f=&quot; + fragment);        mCurTransaction.add(container.getId(), fragment,                makeFragmentName(container.getId(), itemId));    }    if (fragment != mCurrentPrimaryItem) {        fragment.setMenuVisibility(false);        fragment.setUserVisibleHint(false);    }    return fragment;}</code></pre><p>以上代码中，会先判断是否已经加载过这个fragment，如果加载过，就只进行attach操作，不会进行实例化，这样可以节约资源。在上面的前提下，debug到这时第二次进入到fragment后，切换内部的fragment时，在此处mFragmentManager.findFragmentByTag(name);方法返回值都不为空，所以导致了上面提到的BUG。</p><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>在实例化FragmentPagerAdapter类时，需要传递两个参数，将第一个参数设置为getChildFragmentManager()而非getFragmentManager()即可解决问题。</p><p>fragment源码中有getFragmentManager()的说明：</p><pre><code class="java">/**     * Return the FragmentManager for interacting with fragments associated     * with this fragment&#39;s activity.  Note that this will be non-null slightly     * before {@link #getActivity()}, during the time from when the fragment is     * placed in a {@link FragmentTransaction} until it is committed and     * attached to its activity.     *     * &lt;p&gt;If this Fragment is a child of another Fragment, the FragmentManager     * returned here will be the parent&#39;s {@link #getChildFragmentManager()}.     */    final public FragmentManager getFragmentManager() {        return mFragmentManager;    }</code></pre><p>可以理解为：<br>getFragmentManager()是所在fragment 父容器的碎片管理，<br>getChildFragmentManager()是在fragment  里面子容器的碎片管理。</p>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于ThreadLocal的理解</title>
      <link href="/2018/06/19/%E5%85%B3%E4%BA%8EThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/06/19/%E5%85%B3%E4%BA%8EThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>类 ThreadLocal<t>在java.lang包下，jdk1.2提供的方法，1.5后实现的泛型。</t></p><h2 id="官方文档："><a href="#官方文档：" class="headerlink" title="官方文档："></a>官方文档：</h2><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p><p>例如，以下类生成对每个线程唯一的局部标识符。线程 ID 是在第一次调用 UniqueThreadIdGenerator.getCurrentThreadId() 时分配的，在后续调用中不会更改。 </p><pre><code class="java">import java.util.concurrent.atomic.AtomicInteger;public class UniqueThreadIdGenerator {     private static final AtomicInteger uniqueId = new AtomicInteger(0);     private static final ThreadLocal &lt; Integer &gt; uniqueNum =          new ThreadLocal &lt; Integer &gt; () {             @Override protected Integer initialValue() {                 return uniqueId.getAndIncrement();         }     };     public static int getCurrentThreadId() {         return uniqueId.get();     } } // UniqueThreadIdGenerator</code></pre><p> 每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。 </p><h2 id="理解ThreadLocal"><a href="#理解ThreadLocal" class="headerlink" title="理解ThreadLocal"></a>理解ThreadLocal</h2><p>在java开发中，我们很多地方会用到多线程，但是在有些情况下，我们需要在多线程处理过程中的每一个线程单独持有一个特定的对象，并且在操作中进行使用。此时我们就需要该对象就像一个线程的属性一样，能够在各自线程中进行设置与取出或者更改。</p><p>此时sun公司提供了ThreadLocal类：</p><pre><code class="java">public ThreadLocal()//创建一个线程本地变量。 protected T initialValue()//通过这个方法设置一个默认的值//返回此线程局部变量的当前线程的“初始值”。线程第一次使用 get() 方法访问变量时将调用此方法，但如果线程之前调用了 set(T) 方法，则不会对该线程再调用 initialValue 方法。通常，此方法对每个线程最多调用一次，但如果在调用 get() 后又调用了 remove()，则可能再次调用此方法。 该实现返回 null；如果程序员希望线程局部变量具有 null 以外的值，则必须为 ThreadLocal 创建子类，并重写此方法。通常将使用匿名内部类完成此操作。 返回：    返回此线程局部变量的初始值public T get()//返回此线程局部变量的当前线程副本中的值。如果变量没有用于当前线程的值，则先将其初始化为调用 initialValue() 方法返回的值。 返回：    此线程局部变量的当前线程的值public void set(T value)//将此线程局部变量的当前线程副本中的值设置为指定值。大部分子类不需要重写此方法，它们只依靠 initialValue() 方法来设置线程局部变量的值。 参数：    value - 存储在此线程局部变量的当前线程副本中的值。public void remove()//jdk1.5后支持//移除此线程局部变量当前线程的值。如果此线程局部变量随后被当前线程读取，且这期间当前线程没有设置其值，则将调用其 initialValue() 方法重新初始化其值。这将导致在当前线程多次调用 initialValue 方法。 </code></pre><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><pre><code class="java">    //eg:1    private static ThreadLocal&lt;Boolean&gt; hasTran_Local = new ThreadLocal&lt;Boolean&gt;() {        protected Boolean initialValue() {            return false;        };    };    //这里定义了一个ThreadLocal对象hasTran_Local，通过initialValue方法设置了初始值为false，并且可以在线程运行过程中通过set方法进行更改。通过get方法能够得到只属于这个线程的一个boolean值。    //eg:2    private static ThreadLocal&lt;Connection&gt; conn_local = new ThreadLocal&lt;Connection&gt;() {        @Override        protected Connection initialValue() {            return DaoUtils.getConn();        }    };    //这里定义了一个ThreadLocal对象conn_local，在本线程中通过get方法能够得到Connection对象，由于线程第一次使用 get() 方法访问变量时将调用initialValue方法，所以在一个线程中得到的connection是同一个。</code></pre><p>这个方法也能解决JavaEE分层带来的数据库事物操作的问题。</p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android各版本占比信息统计</title>
      <link href="/2018/06/19/Android%E5%90%84%E7%89%88%E6%9C%AC%E5%8D%A0%E6%AF%94%E4%BF%A1%E6%81%AF%E7%BB%9F%E8%AE%A1/"/>
      <url>/2018/06/19/Android%E5%90%84%E7%89%88%E6%9C%AC%E5%8D%A0%E6%AF%94%E4%BF%A1%E6%81%AF%E7%BB%9F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h2 id="一、Android各版本对应的SDK版本："><a href="#一、Android各版本对应的SDK版本：" class="headerlink" title="一、Android各版本对应的SDK版本："></a>一、Android各版本对应的SDK版本：</h2><table><thead><tr><th>平台版本</th><th>SDK版本</th><th>版本名称</th></tr></thead><tbody><tr><td>Android 8.0</td><td>26</td><td>Oreo</td></tr><tr><td>Android 7.1</td><td>25</td><td>Nougat</td></tr><tr><td>Android 7.0</td><td>24</td><td>Nougat</td></tr><tr><td>Android 6.0</td><td>23</td><td>Marshmallow</td></tr><tr><td>Android 5.1</td><td>22</td><td>Lollipop</td></tr><tr><td>Android 5.0</td><td>21</td><td>Lollipop</td></tr><tr><td>Android 4.4</td><td>19</td><td>KITKAT</td></tr><tr><td>Android 4.3</td><td>18</td><td>JELLY_BEAN_MR2</td></tr><tr><td>Android 4.2, 4.2.2</td><td>17</td><td>JELLY_BEAN_MR1</td></tr><tr><td>Android 4.1, 4.1.1</td><td>16</td><td>JELLY_BEAN</td></tr><tr><td>Android 4.0.3, 4.0.4</td><td>15</td><td>ICE_CREAM_SANDWICH_MR1</td></tr><tr><td>Android 4.0, 4.0.1, 4.0.2</td><td>14</td><td>ICE_CREAM_SANDWICH</td></tr><tr><td>Android 3.2</td><td>13</td><td>HONEYCOMB_MR2</td></tr><tr><td>Android 3.1.x</td><td>12</td><td>HONEYCOMB_MR1</td></tr><tr><td>Android 3.0.x</td><td>11</td><td>HONEYCOMB</td></tr><tr><td>Android 2.3.4</td><td>10</td><td>GINGERBREAD_MR1</td></tr><tr><td>Android 2.3.3</td><td>10</td><td>GINGERBREAD_MR1</td></tr><tr><td>Android 2.3.2</td><td>9</td><td>GINGERBREAD</td></tr><tr><td>Android 2.3.1</td><td>9</td><td>GINGERBREAD</td></tr><tr><td>Android 2.3</td><td>9</td><td>GINGERBREAD</td></tr><tr><td>Android 2.2.x</td><td>8</td><td>FROYO</td></tr><tr><td>Android 2.1.x</td><td>7</td><td>ECLAIR_MR1</td></tr><tr><td>Android 2.0.1</td><td>6</td><td>ECLAIR_0_1</td></tr><tr><td>Android 2.0</td><td>5</td><td>ECLAIR</td></tr><tr><td>Android 1.6</td><td>4</td><td>DONUT</td></tr><tr><td>Android 1.5</td><td>3</td><td>CUPCAKE</td></tr><tr><td>Android 1.1</td><td>2</td><td>BASE_1_1</td></tr><tr><td>Android 1.0</td><td>1</td><td>BASE</td></tr></tbody></table><h2 id="二、Android各版本的市场占有率和对应JDK版本"><a href="#二、Android各版本的市场占有率和对应JDK版本" class="headerlink" title="二、Android各版本的市场占有率和对应JDK版本"></a>二、Android各版本的市场占有率和对应JDK版本</h2><table><thead><tr><th>平台版本</th><th>版本名称</th><th>SDK版本</th><th>市场占有率</th><th>JDK版本</th></tr></thead><tbody><tr><td>2.3.3 - 2.3.7</td><td>Gingerbread</td><td>10</td><td>0.4%</td><td>6</td></tr><tr><td>4.0.3 - 4.0.4</td><td>Ice Cream Sandwich</td><td>15</td><td>0.5%</td><td>6</td></tr><tr><td>4.1.x</td><td>Jelly Bean</td><td>16</td><td>2.0%</td><td>6</td></tr><tr><td>4.2.x</td><td>Jelly Bean</td><td>17</td><td>3.0%</td><td>6</td></tr><tr><td>4.3</td><td>Jelly Bean</td><td>18</td><td>0.9%</td><td>6</td></tr><tr><td>4.4</td><td>KitKat</td><td>19</td><td>13.4%</td><td>6</td></tr><tr><td>5.0</td><td>Lollipop</td><td>21</td><td>6.1%</td><td>7</td></tr><tr><td>5.1</td><td>Lollipop</td><td>22</td><td>20.2%</td><td>7</td></tr><tr><td>6.0</td><td>Marshmallow</td><td>23</td><td>29.7%</td><td>-</td></tr><tr><td>7.0</td><td>Nougat</td><td>24</td><td>19.3%</td><td>-</td></tr><tr><td>7.1</td><td>Nougat</td><td>25</td><td>4.0%</td><td>-</td></tr><tr><td>8.0</td><td>Oreo</td><td>26</td><td>0.5%</td><td>-</td></tr></tbody></table><p><img src="http://upload-images.jianshu.io/upload_images/1342270-a3b9ee66686818f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>数据统计日期：截止于 2017 年 12 月 11 日<br>未显示任何分布份额不足 0.1% 的版本。</p><h2 id="三、屏幕尺寸和密度"><a href="#三、屏幕尺寸和密度" class="headerlink" title="三、屏幕尺寸和密度"></a>三、屏幕尺寸和密度</h2><table><thead><tr><th></th><th>ldpi</th><th>mdpi</th><th>tvdpi</th><th>hdpi</th><th>xhdpi</th><th>xxhdpi</th><th>Total</th></tr></thead><tbody><tr><td>Small</td><td>0.6%</td><td></td><td></td><td></td><td></td><td>0.1%</td><td>0.7%</td></tr><tr><td>Normal</td><td></td><td>1.3%</td><td>0.2%</td><td>30.1%</td><td>37.2%</td><td>21.3%</td><td>90.1%</td></tr><tr><td>Large</td><td>0.1%</td><td>2.7%</td><td>1.5%</td><td>0.5%</td><td>1.0%</td><td>0.4%</td><td>6.2%</td></tr><tr><td>Xlarge</td><td></td><td>2.0%</td><td></td><td>0.5%</td><td>0.5%</td><td></td><td>3.0%</td></tr><tr><td>Total</td><td>0.7%</td><td>6.0%</td><td>1.7%</td><td>31.1%</td><td>38.7%</td><td>21.8%</td></tr></tbody></table><p><img src="http://upload-images.jianshu.io/upload_images/1342270-d715c2e5dc6a6be5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="http://upload-images.jianshu.io/upload_images/1342270-959dfac8c8de41cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>数据统计日期：截止于 2017 年 12 月 11 日<br>未显示任何分布份额不足 0.1% 的屏幕配置。</p><h2 id="四、Open-GL-版本"><a href="#四、Open-GL-版本" class="headerlink" title="四、Open GL 版本"></a>四、Open GL 版本</h2><blockquote><p>此部分提供有关相对数量的支持特定 OpenGL ES 版本的设备的数据。请注意，支持某个特定 OpenGL ES 版本，还意味着支持任何更低版本（例如，支持版本 2.0 还意味着支持 1.1）。</p></blockquote><p>要声明您的应用所需的 OpenGL ES 版本，您应使用 <uses-feature> 元素的 android:glEsVersion 属性。您也可以使用 <supports-gl-texture> 元素声明您的应用使用的 GL 压缩格式。</supports-gl-texture></uses-feature></p><table><thead><tr><th>OpenGL ES Version</th><th>占比</th></tr></thead><tbody><tr><td>2.0</td><td>37.0%</td></tr><tr><td>3.0</td><td>45.4%</td></tr><tr><td>3.1</td><td>17.7%</td></tr></tbody></table><p><img src="http://upload-images.jianshu.io/upload_images/1342270-772ea39f6ec65e4d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>数据来源：<a href="http://developer.android.com/about/dashboards/index.html" target="_blank" rel="noopener">Android信息中心</a></p>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在小米、三星等系统应用图标上显示Bage</title>
      <link href="/2018/06/19/%E5%9C%A8%E5%B0%8F%E7%B1%B3%E3%80%81%E4%B8%89%E6%98%9F%E7%AD%89%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E4%B8%8A%E6%98%BE%E7%A4%BABage/"/>
      <url>/2018/06/19/%E5%9C%A8%E5%B0%8F%E7%B1%B3%E3%80%81%E4%B8%89%E6%98%9F%E7%AD%89%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E4%B8%8A%E6%98%BE%E7%A4%BABage/</url>
      <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><blockquote><p>大家经常看见在小米或者三星系统上，应用会把应用的消息数量想苹果手机一样显示在右上角，其实这种消息提示的方法在原生Android上是不支持的，原生的launcher在图标上没有显示徽标的view。</p><p>但是小米、三星、华为、联想、索尼等手机厂商都没有使用原生的launcher，他们使用的桌面都是自己重写的。所以他们都已经实现了在桌面图标上显示消息数量徽标的方法，我们只要进行调用就行了。</p></blockquote><blockquote><p>先上图（设备有限，只有小米和三星）：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/1342270-4abe1df27c1757a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三星手机上的效果"><br><img src="http://upload-images.jianshu.io/upload_images/1342270-355e0c9a97002b2f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小米手机上的效果"></p><h3 id="小米实现的源码："><a href="#小米实现的源码：" class="headerlink" title="小米实现的源码："></a>小米实现的源码：</h3><pre><code class="java">/**     * 在小米手机上显示桌面徽标     *     * @param context     * @param num     */    private static void xiaoMiShortCut(Context context, int num) {        boolean isMiUIV6 = true;        try {            Class miuiNotificationClass = Class.forName(&quot;android.app.MiuiNotification&quot;);            Object miuiNotification = miuiNotificationClass.newInstance();            Field field = miuiNotification.getClass().getDeclaredField(&quot;messageCount&quot;);            field.setAccessible(true);            field.set(miuiNotification, num);// 设置信息数            field = notification.getClass().getField(&quot;extraNotification&quot;);            field.setAccessible(true);            field.set(notification, miuiNotification);        } catch (Exception e) {            e.printStackTrace();            //miui 6之前的版本            isMiUIV6 = false;            Intent localIntent = new Intent(&quot;android.intent.action.APPLICATION_MESSAGE_UPDATE&quot;);            localIntent.putExtra(&quot;android.intent.extra.update_application_component_name&quot;, context.getPackageName() + &quot;/.login.WelcomeActivity&quot;);            localIntent.putExtra(&quot;android.intent.extra.update_application_message_text&quot;, num);            context.sendBroadcast(localIntent);        } finally {            if (notification != null &amp;&amp; isMiUIV6) {                //miui6以上版本需要使用通知发送                nm.notify(10201, notification);            }        }    }</code></pre><h3 id="三星上实现的源码："><a href="#三星上实现的源码：" class="headerlink" title="三星上实现的源码："></a>三星上实现的源码：</h3><pre><code class="java">/**     * 在三星手机上显示桌面徽标     *     * @param context 上下文     * @param num 显示的消息数量，整数     */    private static void samsungShortCut(Context context, int num) {        String launcherClassName = getLaunchActivityName(context);        if (launcherClassName == null) {            return;        }        Intent intent = new Intent(&quot;android.intent.action.BADGE_COUNT_UPDATE&quot;);        intent.putExtra(&quot;badge_count&quot;, num);        intent.putExtra(&quot;badge_count_package_name&quot;, context.getPackageName());        intent.putExtra(&quot;badge_count_class_name&quot;, launcherClassName);        context.sendBroadcast(intent);//        Toast.makeText(context, &quot;三星手机,&quot; + &quot;广播已经发送&quot;, Toast.LENGTH_LONG).show();    }</code></pre><p>###关于MIUI的一点看法<br>1.大家应该已经看出，小米在MIUI6以后和三星的实现方式不一样了，小米将系统的Notification改写成了自己的MiuiNotification，增加了messageCount字段，用于存储消息数量，通过反射将消息数量设置到了messageCount里。此处的num一定要是整数~<br>2.MIUI6以下，通过发送广播即可完成徽标设置~<br>3.通过上面可以发现，MIUI6以上系统，在显示桌面徽标数量的时候是通过统计在系统通知栏中的所有该应用的notification的messageCount的总和，如果你清除了那条通知，那么桌面徽标也就跟随去掉。<br>4.我个人觉得这样的实现方式比较好，也方便进行管理，毕竟显示的徽标也是一种notification，那么就应该和系统通知同步进行管理。</p><h3 id="关于三星的一点看法"><a href="#关于三星的一点看法" class="headerlink" title="关于三星的一点看法"></a>关于三星的一点看法</h3><p>1.在三星的实现方式上，系统通知和桌面徽标数量是没有联系的，三星的桌面应用是TouchWiz.apk，通过反编译可以看到，在launcher类中定义了action为“android.intent.action.BADGE_COUNT_UPDATE”的广播接收者，<img src="http://upload-images.jianshu.io/upload_images/1342270-68ceba66542ae7ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TouchWiz的launcher类"><br>我之前在网上查找到的资料，在设置消息条数的时候设置的都是String类型的，导致我一直不能显示徽标，人家广播接收者里面只接受int类型的。。。<br>2.三星在设置完徽标数量后，是将徽标数量持久化了的，也就是如果你需要去掉徽标，得重新发送广播，将数量设置为0即可。个人觉得没有小米的管理方便~</p><h3 id="关于其他类型手机的徽标设置"><a href="#关于其他类型手机的徽标设置" class="headerlink" title="关于其他类型手机的徽标设置"></a>关于其他类型手机的徽标设置</h3><blockquote><p>通过反编译麻花腾的产品看到，他还判断联想、华为、索尼等产品，附上一些代码（下面代码除华为外，其他没有进行测试#华为的测试结果是跑不通）：</p></blockquote><pre><code class="java">/**     * 创建索尼桌面徽标     *     * @param context     * @param num     */    private static void setSonyBadge(Context context, int num) {        Intent localIntent = new Intent();        String str1 = getLaunchActivityName(context);        if (str1 == null)            return;        boolean isShow = false;        if (num &lt; 1) {            isShow = false;        } else if (num &gt; 99) {            isShow = true;        }        localIntent.putExtra(&quot;com.sonyericsson.home.intent.extra.badge.SHOW_MESSAGE&quot;, isShow);        localIntent.setAction(&quot;com.sonyericsson.home.action.UPDATE_BADGE&quot;);        localIntent.putExtra(&quot;com.sonyericsson.home.intent.extra.badge.ACTIVITY_NAME&quot;, str1);        localIntent.putExtra(&quot;com.sonyericsson.home.intent.extra.badge.MESSAGE&quot;, &quot;&quot;);        localIntent.putExtra(&quot;com.sonyericsson.home.intent.extra.badge.PACKAGE_NAME&quot;, context.getPackageName());        context.sendBroadcast(localIntent);    }</code></pre><pre><code class="java">/**     * 判断是否是联想手机     *     * @param context     * @param paramString     * @return     */    private static boolean islenovoLanucher(Context context, String paramString) {        try {            if (null == packmag)                packmag = context.getPackageManager();            float f = Float.valueOf(Float.parseFloat(packmag.getPackageInfo(paramString, 0).versionName.substring(0, 3))).floatValue();            if (f &gt;= 6.7F)                return true;        } catch (Exception localException) {            return false;        }        return false;    }</code></pre><p>华为可以参见<a href="http://blog.cursorfei.com/2017/12/26/%e5%8d%8e%e4%b8%ba%e6%a1%8c%e9%9d%a2%e6%9c%aa%e8%af%bb%e8%a7%92%e6%a0%87/" target="_blank" rel="noopener">华为桌面未读角标</a></p><p>以上内容仅个人观点，能力有限，如有不足，欢迎指导，勿喷~谢谢</p>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Bage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中对sqlite加密--SQLCipher</title>
      <link href="/2018/06/19/Android%E4%B8%AD%E5%AF%B9sqlite%E5%8A%A0%E5%AF%86-SQLCipher/"/>
      <url>/2018/06/19/Android%E4%B8%AD%E5%AF%B9sqlite%E5%8A%A0%E5%AF%86-SQLCipher/</url>
      <content type="html"><![CDATA[<p>android中有些时候会将一些隐私数据存放在sqlite数据库中，在root过的手机中通过RE就能够轻松的打开并查看数据库所有内容，所以对隐私数据的保护就有两个方法：①将隐私数据自行加密后存入数据库，别人即使打开查看也不知道是什么数据；②将整个数据库进行加密，别人根本就打不开。对于一个数据库中所有数据都需要加密的情况，直接对数据库进行加密是很好的一个解决方案。<br>SQLCipher提供两个版本，一个收费版，一个免费版。收费和免费的功能没多大差别，只是收费的集成更简单方便~这里用免费版进行举例：<br>SQLCipher For Android<br>1、下载 sqlcipher-for-android-community-v3.2.0.zip<br>2、在android studio中新建 assets 文件夹，将下载的文件中assets文件夹中的icudt46l.zip文件拷贝到此处：<br>3、在 mian 目录下新建jniLibs文件夹，并将下载文件中libs文件夹中对应不同平台so文件的文件夹拷贝到此文件夹下；<br>4、将libs下的sqlcipher.jar文件拷贝到 项目的 libs 文件夹下（工程视图切换成project视图）；<br>5、将 sqlcipher.jar “add as library”<br>6、建立 mySqliteOpenHelper 类，继承自导入jar包的 net.sqlcipher.database.SQLiteOpenHelper 类。</p><pre><code class="java">import android.content.Context;import net.sqlcipher.database.SQLiteDatabase;import net.sqlcipher.database.SQLiteOpenHelper;public class mySqliteOpenHelper extends SQLiteOpenHelper { public mySqliteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {        super(context, name, factory, version);    }    @Override    public void onCreate(SQLiteDatabase sqLiteDatabase) {        sqLiteDatabase.execSQL(&quot;create table Book(&quot; +                &quot;_id integer primary key autoincrement,&quot; +                &quot;name text,&quot; +                &quot;price integer)&quot;);    }    @Override    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i2) {    }}</code></pre><p>在操作数据库的类中如下操作：</p><pre><code class="java">SQLiteDatabase.loadLibs(this);//一定不要忘记这句~~        mySqliteOpenHelper helper = new mySqliteOpenHelper(this, &quot;book.db&quot;, null, 1);        //此处指定打开数据库需要的password        db = helper.getWritableDatabase(&quot;pwd&quot;);        db.delete(&quot;Book&quot;,null,null);//清空数据库ContentValues values = new ContentValues();        values.put(&quot;name&quot;, &quot;JAVA编程思想&quot;);        values.put(&quot;price&quot;, 330);        db.insert(&quot;Book&quot;, null, values);        Cursor cursor = db.query(&quot;Book&quot;, null, null, null, null, null, null);        while (cursor.moveToNext()){            System.out.println(&quot;name:&quot;+cursor.getString(cursor.getColumnIndex(&quot;name&quot;)));            System.out.println(&quot;price:&quot;+cursor.getString(cursor.getColumnIndex(&quot;price&quot;)));        }        cursor.close();</code></pre><p>操作完成记得关连接~</p>]]></content>
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> sqlite </tag>
            
            <tag> SQLCipher </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
